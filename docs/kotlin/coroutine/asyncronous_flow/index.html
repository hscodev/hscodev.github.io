<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">Asynchronous Flow | COV</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hscodev.github.io/docs/kotlin/coroutine/asyncronous_flow"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Asynchronous Flow | COV"><meta data-react-helmet="true" name="description" content="suspend 함수는 단일 값을 비동기적으로 반환합니다. flow는 계산된 여러 값을 비동기적으로 반환받을 수 있습니다."><meta data-react-helmet="true" property="og:description" content="suspend 함수는 단일 값을 비동기적으로 반환합니다. flow는 계산된 여러 값을 비동기적으로 반환받을 수 있습니다."><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hscodev.github.io/docs/kotlin/coroutine/asyncronous_flow"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/kotlin/coroutine/asyncronous_flow" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/kotlin/coroutine/asyncronous_flow" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4d477d3e.css">
<link rel="preload" href="/assets/js/runtime~main.4ca9dad8.js" as="script">
<link rel="preload" href="/assets/js/main.62572ae6.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">COV</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">Kotlin</a><a class="navbar__item navbar__link" href="/docs/etc/start_blog">ETC</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">Index</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/kotlin/release/kotlin_1.6">Kotlin 릴리즈 노트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/kotlin/coroutine/coroutine_context_and_dispatchers">Coroutine</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/kotlin/coroutine/coroutine_context_and_dispatchers">Coroutine context and dispatchers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/kotlin/coroutine/asyncronous_flow">Asynchronous Flow</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Asynchronous Flow</h1></header><p>suspend 함수는 단일 값을 비동기적으로 반환합니다. flow는 계산된 여러 값을 비동기적으로 반환받을 수 있습니다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="representing-multiple-values"><strong>Representing multiple values</strong><a aria-hidden="true" class="hash-link" href="#representing-multiple-values" title="Direct link to heading">​</a></h2><p>코들린에서는 Collection으로 여러 값을 나타낼 수 있습니다. 예를 들어, <code>simple()</code> 이라는 함수에서 3개의 숫자를 가진 List를 반환하고 foreach를 사용하여 출력 할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): List&lt;Int&gt; = listOf(1, 2, 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().forEach { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="sequences"><strong>Sequences</strong><a aria-hidden="true" class="hash-link" href="#sequences" title="Direct link to heading">​</a></h3><p>만약 CPU 블로킹 코드로 숫자를 연산한다면, <code>Sequence</code>를 이용해 나타낼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Sequence&lt;Int&gt; = sequence { // sequence builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(100) // pretend we are computing it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        yield(i) // yield next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().forEach { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="suspending-functions"><strong>Suspending functions</strong><a aria-hidden="true" class="hash-link" href="#suspending-functions" title="Direct link to heading">​</a></h3><p>위의 예제들은 메인 스레드를 차단합니다. suspend를 사용하여 함수를 비동기 코드로 변환 할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun simple(): List&lt;Int&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(1000) // pretend we are doing something asynchronous here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return listOf(1, 2, 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().forEach { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flows"><strong>Flows</strong><a aria-hidden="true" class="hash-link" href="#flows" title="Direct link to heading">​</a></h3><p><code>List&lt;Int&gt;</code>를 리턴 타입으로 사용하면, 모든 값을 한번에 반환할 수 밖에 없습니다.  <code>Sequence&lt;Int&gt;</code>의 비동기 형태인 비동기 스트림 <code>Flow&lt;Int&gt;</code> 를 사용할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Launch a concurrent coroutine to check if the main thread is blocked</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (k in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;I&#x27;m not blocked $k&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FlowPractice().simple().collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FlowPractice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun simple(): Flow&lt;Int&gt; = flow { // flow builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(100) // pretend we are doing something useful here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">I&#x27;m not blocked 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I&#x27;m not blocked 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I&#x27;m not blocked 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Flow와 다른 예제의 차이점</p><ul><li>Flow를 만드는 빌더 함수는 <code>flow</code>이다.</li><li><code>flow { ... }</code> 빌더블록 내부 코드는 <code>suspend</code> 할 수 있다.</li><li>flow를 리턴하는 simple 함수 자체는 suspend를 표시할 필요는 없다.</li><li>flow에서 값을 전달할 때는 <code>emit</code> 함수를 사용한다.</li><li>flow에서 값을 수집할 때는 <code>collect</code> 함수를 사용한다.</li></ul><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>flow 예제에서 delay 대신에 Thread.sleep을 사용하면 메인 쓰레드가 중단되는 것을 볼 수 있다.</p></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-are-cold"><strong>Flow are cold</strong><a aria-hidden="true" class="hash-link" href="#flow-are-cold" title="Direct link to heading">​</a></h2><p>Flow는 sequences와 같이 cold stream 입니다. 아래 코드에서 flow builder는 collect 하기전까지 동작하지 않습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Flow started&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delay(100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Calling simple function...&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val flow = simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Calling collect...&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flow.collect { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Calling collect again...&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flow.collect { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Calling simple function...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Calling collect...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flow started</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Calling collect again...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flow started</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>중요한 한가지 아유는 flow를 반환하는 <code>simple</code> 함수가 <code>suspend</code> 함수가 아닙니다. simple 함수의 수행은 빠르게 반환하고 아무것도 기다리지 않습니다. flow는 항상 <code>collect</code>를 호출 할 때마다 시작하고, 재 호출하는 경우에도 다시 시작되는 것을 볼 수 있습니다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-cancellation-basics"><strong>Flow cancellation basics</strong><a aria-hidden="true" class="hash-link" href="#flow-cancellation-basics" title="Direct link to heading">​</a></h2><p>Flow는 코루틴의 일반적인 cooperative cancellation을 따릅니다. 평소처럼 flow가 중단되면 flow의 내부의 delay같은 suspend 함수 역시 취소될 수 있습니다. 다음 예제에서 <code>withTimeoutOrNull</code>를 활용한 중단하는 방법을 볼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delay(100)          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    withTimeoutOrNull(250) { // Timeout after 250ms </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        simple().collect { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Done</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-builders"><strong>Flow builders</strong><a aria-hidden="true" class="hash-link" href="#flow-builders" title="Direct link to heading">​</a></h2><p>flow { ... }는 가장 기본적인 것 중 하나입니다. flow를 더 쉽게 선언 할 수 있는 다른 빌더도 있습니다.</p><ul><li><code>flowOf</code> 빌더는 고정된 값의 set를 반환하는 flow를 만듭니다.</li><li><code>.asFlow()</code> 확장 함수를 사용하여 다양한 컬렉션 및 시퀀스를 flow으로 변환할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">flowOf(1, 2, 3).collect { value -&gt; println(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Convert an integer range to a flow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().collect { value -&gt; println(value) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="intermediate-flow-operators"><strong>Intermediate flow operators</strong><a aria-hidden="true" class="hash-link" href="#intermediate-flow-operators" title="Direct link to heading">​</a></h2><p>Flow는 Collection과 Sequences처럼 연산자를 사용하여 변환할 수 있습니다. 중간 연산자는 업스트림 flow에 적용되고 다운스트림 flow를 반환합니다.  연산자 역시 flow처럼 cold하여 변환만으로는 실행시키지 않습니다. 연산자는 중단 함수로 선언되지 않습니다. 그래서 변환된 flow를 반환하는 것이 빠르게 동작합니다.</p><p>기본적으로 친숙한 연산자는 <code>map</code>과 <code>filter</code>가 있습니다. 시퀀스와의 중요한 차이점은 연산자 블록 내부에서 중단함수를 사용할 수 있습니다.</p><p>예를 들어 장기 수행하는 suspend 함수가 있을 때 flow에 map 연산자를 사용하여 결과에 매핑할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun performRequest(request: Int): String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(1000) // imitate long-running asynchronous work</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &quot;response $request&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (1..3).asFlow() // a flow of requests</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map { request -&gt; performRequest(request) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { response -&gt; println(response) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">response 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">response 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">response 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="transform-operator"><strong>Transform operator</strong><a aria-hidden="true" class="hash-link" href="#transform-operator" title="Direct link to heading">​</a></h2><p>Flow 변환 연산자 가운데 가장 일반적인 것 중 하나는 <code>tranform</code>입니다. 이것은 map과 filter처럼 쉽게 변환할 수 있습니다. 그리고 보다 복잡한 변환을 구현하는데 사용할 수 있습니다.</p><p>예를 들어 <code>transform</code>을 사용하여 비동기성 장기 로직을 시작하기 전에 문자열을 내보낼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain"> (1..3).asFlow() // a flow of requests</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .transform { request -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(&quot;Making request $request&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(performRequest(request)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { response -&gt; println(response) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Making request 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">response 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Making request 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">response 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Making request 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">response 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="size-limiting-operators"><strong>Size-limiting operators</strong><a aria-hidden="true" class="hash-link" href="#size-limiting-operators" title="Direct link to heading">​</a></h2><p>take와 같은 크기 제한 중간 연산자는 제한된 크기에 도달하면 flow의 실행을 취소합니다. 코루틴의 취소는 항상 Exception을 발생합니다. 그래서 try-catch와 같은 자원 관리 함수가 동작됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain"> fun numbers(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {                          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(2) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;This line will not execute&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(3)    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Finally in numbers&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numbers() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .take(2) // take only the first two</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { value -&gt; println(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Finally in numbers</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="terminal-flow-operators"><strong>Terminal flow operators</strong><a aria-hidden="true" class="hash-link" href="#terminal-flow-operators" title="Direct link to heading">​</a></h2><p>flow의 단말 연산자는 collection을 중단 함수로 실행합니다. collect 연산자는 가장 기초적인 것 중 하나지만, 더 쉽게 사용할 수 있는 단말 연산자도 있습니다.</p><ul><li>toList와 toSet을 이용해 다양한 컬렉션으로 변환할 수 있습니다.</li><li>first 연산자는 한 번만 전달 받을 수 있게 보장합니다.</li><li>reduce와 fold를 이용하여 하나의 값으로 줄일 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val sum = (1..5).asFlow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .map { it * it } // squares of numbers from 1 to 5                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reduce { a, b -&gt; a + b } // sum them (terminal operator)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(sum)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flows-are-sequential"><strong>Flows are sequential</strong><a aria-hidden="true" class="hash-link" href="#flows-are-sequential" title="Direct link to heading">​</a></h2><p>각각의 flow 컬렉션은 다중 flow에서 사용되는 특수한 연산자를 사용하지 않는 한 순차적으로 발생합니다. 컬렉션은 단말 연산자를 사용하는 코루틴에서 직접 동작합니다. 기본적으로 새로운 코루틴으로 동작하지는 않습니다. 각 값의 전달은 업스트림에서 다운스트림으로 모든 중간 연산자에 의해 처리된 다음 터미널 연산자에 전달됩니다.</p><p>다음 예제는 짝수를 filter하여 map을 이용해 String으로 전달합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">(1..5).asFlow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .filter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Filter $it&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        it % 2 == 0              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .map { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Map $it&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;string $it&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.collect { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Collect $it&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Filter 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Filter 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collect string 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Filter 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Filter 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collect string 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Filter 5</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-context"><strong>Flow context</strong><a aria-hidden="true" class="hash-link" href="#flow-context" title="Direct link to heading">​</a></h2><p>flow의 collection은 항상 coroutine의 context 안에서 발생합니다. 예를 들어 simple flow가 있을 때,</p><p>다음 코드는 flow에 구현한 세부 사항에 상관 없이 작성자가 명시한 context 안에서 실행됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">withContext(context) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value) // run in the specified context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 flow의 속성은 유지된 context에 의해 호출됩니다.</p><p>그래서 기본적으로 <code>flow { ... }</code> 빌더의 내부 코드는 flow의 collector가 제공하는 context 안에서 실행됩니다. 예를 들어, 아래 simple 함수에서 호출하거나 전달하는 구현은 쓰레드를 고려해야 합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log(&quot;Started simple flow&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().collect { value -&gt; log(&quot;Collected $value&quot;) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] Started simple flow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] Collected 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] Collected 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] Collected 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>simple().collect</code>는 메인 쓰레드에서 호출되었고, flow builder의 내부 구현도 메인 쓰레드에서 동작하였습니다. 이것은 빠르게 실행하거나 비동기 코드에 대한 기초이며, 실행 context와 호출자의 차단을 신경쓰지 않습니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="wrong-emission-withcontext"><strong>Wrong emission withContext</strong><a aria-hidden="true" class="hash-link" href="#wrong-emission-withcontext" title="Direct link to heading">​</a></h3><p>장기 실행하여 CPU를 소모하는 코드는 Dispatchers.Default의 context 사용이 필요하고, UI를 갱신하는 코드는 Dispatchers.Main의 context를 사용해야 할 필요가 있을 것입니다. 일반적으로 withContext는 coroutine에서 context를 변경하기 위해 사용되는데, <code>flow { ... }</code> 빌더의 내부 코드는 context 속성을 유지게되고 다른 context에서 emit의 호출은 허용되지 않습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain"> fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // The WRONG way to change context for CPU-consuming code in flow builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kotlinx.coroutines.withContext(Dispatchers.Default) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100) // pretend we are computing it in CPU-consuming way</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().collect { value -&gt; println(value) } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Flow invariant is violated:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Flow was collected in [CoroutineId(1), &quot;coroutine#1&quot;:BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        but emission happened in [CoroutineId(1), &quot;coroutine#1&quot;:DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Please refer to &#x27;flow&#x27; documentation or use &#x27;flowOn&#x27; instead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    at ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flowon-operator"><strong>flowOn operator</strong><a aria-hidden="true" class="hash-link" href="#flowon-operator" title="Direct link to heading">​</a></h3><p>예외적으로 flowOn 함수를 사용하여 flow를 전달하는데 사용하는 context를 변경할 수 있습니다. 아래의 코드에서 flow의 context 변경의 올바른 코드를 볼 수 있고, 쓰레드가 어떻게 변화하는지 볼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(100) // pretend we are computing it in CPU-consuming way</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple().collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log(&quot;Collected $value&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 결과에서 <code>flow{ ... }</code> 블록은 백그라운드 쓰레드에서 동작하고 collection은 메인 쓰레드에서 동작 한것을 주목하세요.</p><p>또다른 주목할만한 점은 flowOn 연산자는 flow의 기본적인 순서대로 전환된 것입니다. collection은 coroutine#1에서 발생하고, 전달은 coroutine#2로 발생하는 동시에 각각 다른 쓰레드에서 동작하였습니다. flowOn 연산자는 CoroutineDispatcher의 변경이 있을 때, upstream flow에 대한 또다른 코루틴을 생성합니다.</p><p>flowOn이더라도 같은 Dispatchers인 경우 다른 코루틴을 생성하지 않습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    withContext(Dispatchers.Default){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlowPractice().simple().collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FlowPractice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100) // pretend we are computing it in CPU-consuming way</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] Emitting 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DefaultDispatcher-worker-1 @coroutine#1] 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="buffering"><strong>Buffering</strong><a aria-hidden="true" class="hash-link" href="#buffering" title="Direct link to heading">​</a></h2><p>flow의 일부분을 다른 코루틴에서 동작하는 것은 장기적으로 실행되는 비동기 작업에서 사용하면 전체 실행시간에 도움이 될 것입니다. 예를들어 flow에서 값 전달이 100ms마다 발생하는고 collector 내부의 코드가 300ms만큼 지연되는 경우 고려해볼만 합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val time = measureTimeMillis {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlowPractice().simple().collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(300) // pretend we are processing it for 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Collected in $time ms&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FlowPractice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(100) // pretend we are asynchronously waiting 100 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        log(&quot;delay $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] delay 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] delay 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] delay 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collected in 1259 ms</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>buffer</code> 연산자를 사용하여 전달 코드와 collect 코드를 각자 동시에 실행할 수 있습니다.</p><p>❗Collect 연산을 기다리지 않고 다음 flow 내부 코드가 계속 동작합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val time = measureTimeMillis {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlowPractice().simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .buffer() // buffer emissions, don&#x27;t wait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                delay(300) // pretend we are processing it for 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Collected in $time ms&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FlowPractice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(100) // pretend we are asynchronously waiting 100 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(&quot;delay $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#2] delay 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#2] delay 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#2] delay 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main @coroutine#1] 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collected in 1089 ms</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>flowOn 연산자에서 CoroutineDispatcher가 바뀔 때 동작하는 버퍼링 메커니즘과 동일합니다. 하지만 buffering 연산자는 실행 context가 변경되지 않습니다.</p></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="conflation"><strong>Conflation</strong><a aria-hidden="true" class="hash-link" href="#conflation" title="Direct link to heading">​</a></h3><p>연산의 부분적인 결과를 전달하거나 연산의 상태를 업데이트를 연속적으로 전달하는 경우 각 값을 처리할 필요가 없이 최근 값만 처리할 수 있습니다. 예를 들어 <code>conflate</code> 연산자는 collector의 처리가 느린 경우 중간값을 생략할 수 있습니다.</p><p>❗처리해야 하는 값 중 다음 값을 이미 받을 수 있는 상태인 경우 생략</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val time = measureTimeMillis {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .conflate() // conflate emissions, don&#x27;t process each one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { value -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(300) // pretend we are processing it for 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(value) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Collected in $time ms&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collected in 760 ms</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="processing-the-latest-value"><strong>Processing the latest value</strong><a aria-hidden="true" class="hash-link" href="#processing-the-latest-value" title="Direct link to heading">​</a></h3><p>Conflation은 flow와 collector 둘 다 느릴 때 빠르게 하는 방법 중 하나입니다. 이것은 전달하는 값을 버리는 것 입니다. 느린 collector 연산을 취소하고 새로운 값을 전달하는 다른 방법이 있습니다. <code>xxxLatest</code> 연산 모음은  <code>xxx</code> 연산의 로직을 수행 중 새 값이 발생하는 경우 중단시킵니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val time = measureTimeMillis {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collectLatest { value -&gt; // cancel &amp; restart on the latest value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;Collecting $value&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay(300) // pretend we are processing it for 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;Done $value&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Collected in $time ms&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] delay 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[main] 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collected in 680 ms</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="composing-multiple-flows"><strong>Composing multiple flows</strong><a aria-hidden="true" class="hash-link" href="#composing-multiple-flows" title="Direct link to heading">​</a></h2><p>다중 flow를 구성하는 여러 방법이 있습니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="zip"><strong>Zip</strong><a aria-hidden="true" class="hash-link" href="#zip" title="Direct link to heading">​</a></h3><p>코틀린 기본 라이브러리의 시퀀스의 zip같은 확장 함수 처럼 flow에도 두개의 flow를 병합하여 전달하는 <code>zip</code> 연산자가 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val nums = (1..3).asFlow() // numbers 1..3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) // strings </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nums.zip(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { println(it) } // collect and print</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1 -&gt; one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 -&gt; two</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 -&gt; three</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="combine"><strong>Combine</strong><a aria-hidden="true" class="hash-link" href="#combine" title="Direct link to heading">​</a></h3><p>flow가 변수 또는 작업의 가장 최근 값을 전달하는 경우 값에 따라 계산을 수행하고 업스트림 flow에서 값을 전달할 때마다 이를 다시 계산해야 할 수 있습니다. 이 연산자 집합을 <code>combine</code>이라고 합니다.</p><p>예를 들어, 이전 예제에서 숫자가 300ms, 문자열은 400ms마다 전달 된다면 zip 연산자는 이전과 같은 결과를 400ms마다 출력하게 될 것입니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;).onEach { delay(400) } // strings every 400 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val startTime = System.currentTimeMillis() // remember the start time </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nums.zip(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string with &quot;zip&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; // collect and print </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1 -&gt; one at 432 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 -&gt; two at 833 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 -&gt; three at 1243 ms from start</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>그러나 <code>combine</code> 연산자는 둘 중 하나의 값이 전달될 때마다 출력하는 것을 볼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;).onEach { delay(400) } // strings every 400 ms          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val startTime = System.currentTimeMillis() // remember the start time </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nums.combine(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string with &quot;combine&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; // collect and print </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1 -&gt; one at 452 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 -&gt; one at 651 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 -&gt; two at 854 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 -&gt; two at 952 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 -&gt; three at 1256 ms from start</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flattening-flows"><strong>Flattening flows</strong><a aria-hidden="true" class="hash-link" href="#flattening-flows" title="Direct link to heading">​</a></h2><p>flow는 순차적인 값을 비동기적으로 제공합니다. 그리고 전달받는 각 값으로 다른 flow를 실행하는 것 또한 매우 쉽습니다.</p><p>예를 들어 500ms 간격으로 두개의 문자열을 반환하는 flow 함수를 볼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun requestFlow(i: Int): Flow&lt;String&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    emit(&quot;$i: First&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(500) // wait 500 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    emit(&quot;$i: Second&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>여기서 다음과 같이 3개의 숫자를 전달하는 flow에서 호출할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().map { requestFlow(it) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>그런 다음 flow의 flow 값(<code>Flow&lt;Flow&lt;String&gt;&gt;</code>)은 추가적인 처리를 위한 단일 flow로 평탄화 할 필요가 있습니다. 이를 위해 Collections와 Sequences에는 flatten과 flatMap 연산자가 있습니다. 그러나</p><p>flow는 비동기적 특성으로 인해 flow의 평탄화 연산자는 다른 방식으로 실행해야 합니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flatmapconcat"><strong>flatMapConcat</strong><a aria-hidden="true" class="hash-link" href="#flatmapconcat" title="Direct link to heading">​</a></h3><p>병합 방식은 <code>flatMapConcat</code>이나 <code>flattenConcat</code> 연산자로 구현합니다. 이것은 시퀀스 연산자에 가장 비슷합니다. 이 때 flow의 각 값 전달은 내부 flow의 collect가 끝날때까지 대기한 후에 실행됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val startTime = System.currentTimeMillis() // remember the start time </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().onEach { delay(100) } // a number every 100 ms </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flatMapConcat { requestFlow(it) }                                                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; // collect and print </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>flatMapConcat</code>의 순차적인 특성은 출력과 같습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1: First at 121 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1: Second at 622 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: First at 727 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: Second at 1227 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: First at 1328 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: Second at 1829 ms from start</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flatmapmerge"><strong>flatMapMerge</strong><a aria-hidden="true" class="hash-link" href="#flatmapmerge" title="Direct link to heading">​</a></h3><p>다른 평탄화 방식은 전달되는 모든 flow를 동시에 collect하고 단일 flow로 병합하여 가능한 한 빠르게 전달하는 것입니다. 이것은 <code>flatMapMerge</code>나 <code>flattenMerge</code> 연산자로 구현할 수 있습니다. 두 연산자 모두 collect 되는 flow의 수를 제한하는 인자를 사용할 수 있습니다. 기본적으로는 DEFAULT_CONCURRENCY와(16) 같습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val startTime = System.currentTimeMillis() // remember the start time </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().onEach { delay(100) } // a number every 100 ms </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flatMapMerge { requestFlow(it) }                                                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; // collect and print </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1: First at 136 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: First at 231 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: First at 333 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1: Second at 639 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: Second at 732 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: Second at 833 ms from start</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p><code>flatMapMerge</code>는 코드 블록을 순차적으로 호출하지만 flow의 결과를 동시에 수집합니다. 이는 순차적으로 <code>map { requestFlow(it) }</code>를 먼저 수행한 다음 <code>flattenMerge</code>를 호출하는 것과 동일합니다.</p></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().onEach { delay(100) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map { FlowPractice().requestFlow(it)  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flattenMerge()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flatmaplatest"><strong>flatMapLatest</strong><a aria-hidden="true" class="hash-link" href="#flatmaplatest" title="Direct link to heading">​</a></h3><p>Processing the latest Value 문단에서 볼 수 있는 collectLatest 연산자와 비슷한 방법으로서, 새로운 flow가 전달되면 이전 flow는 중단되는 평탄화 방식입니다. <code>flatMapLatest</code> 연산자로 구현할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val startTime = System.currentTimeMillis() // remember the start time </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..3).asFlow().onEach { delay(100) } // a number every 100 ms </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flatMapLatest { requestFlow(it) }                                                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; // collect and print </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1: First at 142 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2: First at 322 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: First at 425 ms from start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3: Second at 931 ms from start</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p><code>flatMapLatest</code>는 새 값에서 기존 코드를 취소합니다. <code>requestFlow</code> 가 빠르게 동작하거나 중단 함수를 사용하지 않거나 취소할 수 없는 경우 다른 예제와 같은 동작을 할 수 있습니다. 그러나 <code>delay</code>와 같은 일시 중단 기능을 사용하면 차이를 볼 수 있습니다.</p></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-exceptions"><strong>Flow exceptions</strong><a aria-hidden="true" class="hash-link" href="#flow-exceptions" title="Direct link to heading">​</a></h2><p>Flow는 값을 전달할 때나 코드 내부에서 예외가 발생했을때 완벽히 처리할 수 있습니다. 몇몇 예외처리 방법을 소개합니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="collector-try-and-catch"><strong>Collector try and catch</strong><a aria-hidden="true" class="hash-link" href="#collector-try-and-catch" title="Direct link to heading">​</a></h3><p>kotlin의 <code>try-catch</code> 구문으로 예외처리 할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        simple().collect { value -&gt;         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            check(value &lt;= 1) { &quot;Collected $value&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (e: Throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Caught $e&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Caught java.lang.IllegalStateException: Collected 2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>위 코드는 collect 단말 연산자 내에서 발생하는 예외에 대해 처리되고 추가적인 값 처리를 하지 않는 것을 볼 수 있습니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="everything-is-caught"><strong>Everything is caught</strong><a aria-hidden="true" class="hash-link" href="#everything-is-caught" title="Direct link to heading">​</a></h3><p>이전 예제에서는 전달자나 중간 연산자, 단말 연산자에서 발생하는 모든 예외를 처리합니다. 예를 들어 전달 값이 문자열에 매핑되도록 코드를 변경해도 그 코드는 예외를 발생합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;String&gt; = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emit(i) // emit next value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .map { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        check(value &lt;= 1) { &quot;Crashed on $value&quot; }                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;string $value&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        simple().collect { value -&gt; println(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (e: Throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Caught $e&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">string 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Caught java.lang.IllegalStateException: Crashed on 2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="exception-transparency"><strong>Exception transparency</strong><a aria-hidden="true" class="hash-link" href="#exception-transparency" title="Direct link to heading">​</a></h2><p>flow는 예외에 대해 투명해야 하며 try/catch 내부에서 <code>flow { ... }</code> 빌더를 통해 값을 전달하는 것은 예외 투명성에 위배됩니다. 예퇴의 투명성은 이전 예제의 try/catch 처럼 collector에서 발생하는 예외를 항상 처리할 수 있도록 보장합니다.</p><p>전달자는 <code>catch</code> 연산자를 사용할 수 있습니다. 이것은 예외 투명성을 제공하고 예외처리의 캡슐화를 할 수 있습니다. catch 연산자의 구현 부분은 예외를 분석할 수 있고 예외에 종류에 따라 다르게 처리할 수 있습니다.</p><ul><li><code>throw</code>를 이용하여 다시 예외를 발생할 수 있습니다.</li><li><code>catch</code>의 구현 부분에서도 emit을 이용하여 값을 전달할 수 있습니다.</li><li>예외는 무시하거나 로깅하거나 처리할 수 있습니다.</li></ul><p>다음 예제처럼 예외가 발생하면 문자열을 전달할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .catch { e -&gt; emit(&quot;Caught $e&quot;) } // emit on exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; println(value) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="transparent-catch"><strong>Transparent catch</strong><a aria-hidden="true" class="hash-link" href="#transparent-catch" title="Direct link to heading">​</a></h3><p><code>catch</code> 중간 연산자는 예외 투명성을 제공하고 업스트림의 예외만 잡습니다. catch보다 먼저 선언된 연산자들에 대한 예외만 잡으며 이후 선언된 경우 잡지 않습니다. 만약 catch 아래에 선언된 collect에서 예외가 발생하면 다음과 같이 escape됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Emitting $i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .catch { e -&gt; println(&quot;Caught $e&quot;) } // does not catch downstream exceptions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            check(value &lt;= 1) { &quot;Collected $value&quot; }                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(value) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Collected 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> at FileKt$main$1$invokeSuspend$$inlined$collect$1.emit (Collect.kt:135) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> at kotlinx.coroutines.flow.FlowKt__ErrorsKt$catchImpl$$inlined$collect$1.emit (Collect.kt:136) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> at kotlinx.coroutines.flow.internal.SafeCollectorKt$emitFun$1.invoke (SafeCollector.kt:15)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="catching-declaratively"><strong>Catching declaratively</strong><a aria-hidden="true" class="hash-link" href="#catching-declaratively" title="Direct link to heading">​</a></h3><p>catch 연산자로 collect 영역을 포함한 모든 오류를 제어하고 싶은 경우 <code>onEach</code>를 catch 연산자 이전에 구현하여 처리할 수 있습니다. 이 Flow Collection은 구현 없이 <code>collect()</code>만을 호출하여 실행할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .onEach { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        check(value &lt;= 1) { &quot;Collected $value&quot; }                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .catch { e -&gt; println(&quot;Caught $e&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Caught java.lang.IllegalStateException: Collected 2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-completion"><strong>Flow completion</strong><a aria-hidden="true" class="hash-link" href="#flow-completion" title="Direct link to heading">​</a></h2><p>Flow의 수집이 일반적으로나 예외 발생으로 완료되면 추가적인 처리가 필요할 수 있습니다. 이미 알아챘을 수 있겠지만 <code>명령형</code> 혹은 <code>선언형</code>으로 처리할 수 있습니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="imperative-finally-block"><strong>Imperative finally block</strong><a aria-hidden="true" class="hash-link" href="#imperative-finally-block" title="Direct link to heading">​</a></h3><p><code>try/catch</code>의 <code>finally</code> 블록을 이용할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        simple().collect { value -&gt; println(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Done</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="declarative-handling"><strong>Declarative handling</strong><a aria-hidden="true" class="hash-link" href="#declarative-handling" title="Direct link to heading">​</a></h3><p>선언형으로 접근하면 flow에는 수집이 완료되면 호출 되는 <code>onCompletion</code> 중간 연산자가 있습니다.</p><p><code>onCompletion</code> 연산자를 사용하여 아래와 같이 작성하면 이전 예제와 같은 결과를 볼 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .onCompletion { println(&quot;Done&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect { value -&gt; println(value) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>onCompletion</code>의 주요한 이점은 <code>Throwable</code> 인자의 nullable 상태를 통해 정상 완료인지 오류에 의한 완료인지 파악이 가능합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = flow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    emit(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw RuntimeException()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .onCompletion { cause -&gt; if (cause != null) println(&quot;Flow completed exceptionally&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .catch { cause -&gt; println(&quot;Caught exception&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { value -&gt; println(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flow completed exceptionally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Caught exception</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>onCompletion</code> 연산자는 <code>catch</code> 연산자와 달리 예외를 처리하지 않습니다. 위의 예제 코드에서 볼 수 있듯이 예외는 여전히 다운스트림으로 흐릅니다. <code>catch</code>에서 예외를 처리하고 <code>onCompletion</code>으로 거슬러 올라가 전달합니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="successful-completion"><strong>Successful completion</strong><a aria-hidden="true" class="hash-link" href="#successful-completion" title="Direct link to heading">​</a></h3><p>catch와 onCompletion의 또다른 차이점은 모든 예외를 전달 받을 수 있고, flow의 업스트림이 성공적으로 완료된 경우에는 null 인자를 전달받습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    simple()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .onCompletion { cause -&gt; println(&quot;Flow completed with $cause&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            check(value &lt;= 1) { &quot;Collected $value&quot; }                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(value) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>다운스트림 예외로 인해 flow가 중단되었기 때문에 예외가 null이 아님을 알 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flow completed with java.lang.IllegalStateException: Collected 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Collected 2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="imperative-versus-declarative"><strong>Imperative versus declarative</strong><a aria-hidden="true" class="hash-link" href="#imperative-versus-declarative" title="Direct link to heading">​</a></h2><p>지금까지 flow를 수집하는 방법과 완료와 예외에 대해 선언형, 명령형 두가지 방법으로 처리하는 방법을 알게 되었습니다. 자연스럽게 어느걸 우선적으로, 왜 써야하는지 궁금증이 생길 수 있습니다. 공식적으로는 두 옵션 모두 유효하며 자신의 기본 설정과 코드 스타일에 따라 선택할 수 있다고 생각합니다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="launching-flow"><strong>Launching flow</strong><a aria-hidden="true" class="hash-link" href="#launching-flow" title="Direct link to heading">​</a></h2><p>일부 소스의 정보를 flow 비동기 이벤트로 쉽게 사용할 수 있습니다. 그 외에도 addEventListener를 이용하여 코드의 일부에 대해 이벤트 처리를 하거나 더 나아가 코루틴을 처리할 필요도 있습니다. onEach 연산자는 이 역할을 할 수 있습니다. 그러나 onEach는 중간 연산자여서 실행이 불가능하고 단말 연산자도 필요합니다.</p><p>oneEach 다음에 collect 단말 연산자를 사용한 후에 코드는 flow에 값이 전달 될 때까지 대기합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// Imitate a flow of events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    events()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .onEach { event -&gt; println(&quot;Event: $event&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect() // &lt;--- Collecting the flow waits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Event: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event: 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event: 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Done</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 경우 <code>launchIn</code> 터미널 연산자가 유용합니다. <code>collect</code>를 <code>launchIn</code>으로 변경하면 별도의 코루틴에서 flow collection을 시작하여 즉시 추가 코드가 실행됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    events()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .onEach { event -&gt; println(&quot;Event: $event&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .launchIn(this) // &lt;--- Launching the flow in a separate coroutine</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event: 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event: 3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>launchIn</code>에 대한 필수 매개변수는 코루틴이 시작되는 <code>CoroutineScope</code>를 지정해야 합니다. 위의 예에서 scope는 <code>runBlocking</code> 코루틴 빌더에서 가져오므로 flow가 실행되는 동안 이 <code>runBlocking</code> scope는 자식 코루틴이 완료될 때까지 대기하고 main 함수가 종료하지 않도록 합니다.</p><p>실제 응용 프로그램에서 scope는 수명이 제한된 엔터티에서 가져옵니다. 이 엔터티의 수명이 종료되는 즉시 해당 scope가 취소되고 해당 flow의 collection이 취소됩니다. 이런 식으로 <code>oneEach { ... }.launchIn(scope)</code> 는  <code>addEventListener</code>처럼 작동합니다. 그리고 <code>removeEventListener</code> 함수 대신에 취소와 구조화된 동시성으로 완료될 수 있습니다.</p><p>그리고 <code>launchIn</code>은 모든 Scope를 <code>join</code>하거나 flow 코루틴을 취소하는 데 사용할 수 있는 <code>Job</code>을 반환합니다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="flow-cancellation-checks"><strong>Flow cancellation checks</strong><a aria-hidden="true" class="hash-link" href="#flow-cancellation-checks" title="Direct link to heading">​</a></h3><p>Flow Builder는 전달된 값에 따라 취소하기 위해 <code>sureActive</code> 검사를 수행할 수 있습니다. <code>flow { ... }</code> 에서 값이 전달되는 중에도 루프를 취소할 수 있음을 의미합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun foo(): Flow&lt;Int&gt; = flow { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i in 1..5) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Emitting $i&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emit(i) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo().collect { value -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value == 3) cancel()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitting 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@6d7b4f4c</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>그러나 대부분의 다른 flow 연산자는 성능상의 이유로 취소를 위한 자체적인 검사를 수행하지 않습니다. 예를 들어 <code>IntRange.asFlow</code> 확장 함수를 사용하여 동일한 루프를 작성하면 중단 함수가 없기 떄문에 취소에 대한 검사가 없습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (1..5).asFlow().collect { value -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value == 3) cancel()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@3327bd23</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="making-busy-flow-cancellable"><strong>Making busy flow cancellable</strong><a aria-hidden="true" class="hash-link" href="#making-busy-flow-cancellable" title="Direct link to heading">​</a></h3><p>이 경우 취소를 검사하도록 명시할 수 있습니다.  <code>.onEach { currentCoroutineContext().ensureActive() }</code> 를 구현하여 추가할 수 있는데, <code>cancellable</code> 연산자를 이용하여 동일하게 사용할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking&lt;Unit&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (1..5).asFlow().cancellable().collect { value -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value == 3) cancel()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@5ec0a365</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="flow-and-reactive-streams"><strong>Flow and Reactive Streams</strong><a aria-hidden="true" class="hash-link" href="#flow-and-reactive-streams" title="Direct link to heading">​</a></h2><p>RxJava나 Reactor와 같은 Reactive Framework나 Reactive Streams 처럼 Flow 역시 매우 친숙하게 디자인 되어있습니다.</p><p>실제로 그 디자인은 Reactive Streams와 다양한 구현에서 영감을 받았습니다. 그러나 Flow의 주요 목표는 가능한 한 단순한 디자인과 Kotlin 및 서스펜션 친화적이며 동시성을 지원하는 것입니다. 이 목표를 달성하는 것은 리액티브 개척자들과 그들의 엄청난 노력 없이는 불가능했을 것입니다. <a href="https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4" target="_blank" rel="noopener noreferrer">Reactive Streams and Kotlin Flows</a>에서 전체 스토리를 읽을 수 있습니다.</p><p>개념적으로는 다르지만 Flow는 리액티브 스트림이며 다른 Reactive 모듈의 기능으로 변환하거나 반대로 변환할 수 있습니다. 이러한 변환기는 기본적으로 <code>kotlinx.coroutines</code>에 의해 제공되며 다음Reactive 모듈을 이용할 수 있습니다. (Reactive Streams은 <code>kotlinx-coroutines-reactive</code>, Project Reactor는 <code>kotlinx-coroutines-reactor</code> , RxJava2/RxJava3는 <code>kotlinx-coroutines-rx2/kotlinx-coroutines-rx3</code> ). 통합 모듈에는 Flow에서의 변환이나 Reactor의 컨텍스트 통합 그리고 다양한 Reactive Entity와 서스펜션 친화적인 작업 방법을 제공합니다.</p></div></article><div class="comment-container"></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#representing-multiple-values" class="table-of-contents__link toc-highlight"><strong>Representing multiple values</strong></a><ul><li><a href="#sequences" class="table-of-contents__link toc-highlight"><strong>Sequences</strong></a></li><li><a href="#suspending-functions" class="table-of-contents__link toc-highlight"><strong>Suspending functions</strong></a></li><li><a href="#flows" class="table-of-contents__link toc-highlight"><strong>Flows</strong></a></li></ul></li><li><a href="#flow-are-cold" class="table-of-contents__link toc-highlight"><strong>Flow are cold</strong></a></li><li><a href="#flow-cancellation-basics" class="table-of-contents__link toc-highlight"><strong>Flow cancellation basics</strong></a></li><li><a href="#flow-builders" class="table-of-contents__link toc-highlight"><strong>Flow builders</strong></a></li><li><a href="#intermediate-flow-operators" class="table-of-contents__link toc-highlight"><strong>Intermediate flow operators</strong></a></li><li><a href="#transform-operator" class="table-of-contents__link toc-highlight"><strong>Transform operator</strong></a></li><li><a href="#size-limiting-operators" class="table-of-contents__link toc-highlight"><strong>Size-limiting operators</strong></a></li><li><a href="#terminal-flow-operators" class="table-of-contents__link toc-highlight"><strong>Terminal flow operators</strong></a></li><li><a href="#flows-are-sequential" class="table-of-contents__link toc-highlight"><strong>Flows are sequential</strong></a></li><li><a href="#flow-context" class="table-of-contents__link toc-highlight"><strong>Flow context</strong></a><ul><li><a href="#wrong-emission-withcontext" class="table-of-contents__link toc-highlight"><strong>Wrong emission withContext</strong></a></li><li><a href="#flowon-operator" class="table-of-contents__link toc-highlight"><strong>flowOn operator</strong></a></li></ul></li><li><a href="#buffering" class="table-of-contents__link toc-highlight"><strong>Buffering</strong></a><ul><li><a href="#conflation" class="table-of-contents__link toc-highlight"><strong>Conflation</strong></a></li><li><a href="#processing-the-latest-value" class="table-of-contents__link toc-highlight"><strong>Processing the latest value</strong></a></li></ul></li><li><a href="#composing-multiple-flows" class="table-of-contents__link toc-highlight"><strong>Composing multiple flows</strong></a><ul><li><a href="#zip" class="table-of-contents__link toc-highlight"><strong>Zip</strong></a></li><li><a href="#combine" class="table-of-contents__link toc-highlight"><strong>Combine</strong></a></li></ul></li><li><a href="#flattening-flows" class="table-of-contents__link toc-highlight"><strong>Flattening flows</strong></a><ul><li><a href="#flatmapconcat" class="table-of-contents__link toc-highlight"><strong>flatMapConcat</strong></a></li><li><a href="#flatmapmerge" class="table-of-contents__link toc-highlight"><strong>flatMapMerge</strong></a></li><li><a href="#flatmaplatest" class="table-of-contents__link toc-highlight"><strong>flatMapLatest</strong></a></li></ul></li><li><a href="#flow-exceptions" class="table-of-contents__link toc-highlight"><strong>Flow exceptions</strong></a><ul><li><a href="#collector-try-and-catch" class="table-of-contents__link toc-highlight"><strong>Collector try and catch</strong></a></li><li><a href="#everything-is-caught" class="table-of-contents__link toc-highlight"><strong>Everything is caught</strong></a></li></ul></li><li><a href="#exception-transparency" class="table-of-contents__link toc-highlight"><strong>Exception transparency</strong></a><ul><li><a href="#transparent-catch" class="table-of-contents__link toc-highlight"><strong>Transparent catch</strong></a></li><li><a href="#catching-declaratively" class="table-of-contents__link toc-highlight"><strong>Catching declaratively</strong></a></li></ul></li><li><a href="#flow-completion" class="table-of-contents__link toc-highlight"><strong>Flow completion</strong></a><ul><li><a href="#imperative-finally-block" class="table-of-contents__link toc-highlight"><strong>Imperative finally block</strong></a></li><li><a href="#declarative-handling" class="table-of-contents__link toc-highlight"><strong>Declarative handling</strong></a></li><li><a href="#successful-completion" class="table-of-contents__link toc-highlight"><strong>Successful completion</strong></a></li></ul></li><li><a href="#imperative-versus-declarative" class="table-of-contents__link toc-highlight"><strong>Imperative versus declarative</strong></a></li><li><a href="#launching-flow" class="table-of-contents__link toc-highlight"><strong>Launching flow</strong></a><ul><li><a href="#flow-cancellation-checks" class="table-of-contents__link toc-highlight"><strong>Flow cancellation checks</strong></a></li><li><a href="#making-busy-flow-cancellable" class="table-of-contents__link toc-highlight"><strong>Making busy flow cancellable</strong></a></li></ul></li><li><a href="#flow-and-reactive-streams" class="table-of-contents__link toc-highlight"><strong>Flow and Reactive Streams</strong></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 COV. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4ca9dad8.js"></script>
<script src="/assets/js/main.62572ae6.js"></script>
</body>
</html>