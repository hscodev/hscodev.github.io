<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">Coroutine context and dispatchers | COV</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hscodev.github.io/docs/kotlin/coroutine/coroutine_context_and_dispatchers"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Coroutine context and dispatchers | COV"><meta data-react-helmet="true" name="description" content="코루틴은 여러 유형들이 CoroutineContext가 있으며, 이것이 제공하는 context에서 실행 됩니다."><meta data-react-helmet="true" property="og:description" content="코루틴은 여러 유형들이 CoroutineContext가 있으며, 이것이 제공하는 context에서 실행 됩니다."><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hscodev.github.io/docs/kotlin/coroutine/coroutine_context_and_dispatchers"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/kotlin/coroutine/coroutine_context_and_dispatchers" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/kotlin/coroutine/coroutine_context_and_dispatchers" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4d477d3e.css">
<link rel="preload" href="/assets/js/runtime~main.83ea7414.js" as="script">
<link rel="preload" href="/assets/js/main.e2d59c23.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">COV</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">Kotlin</a><a class="navbar__item navbar__link" href="/docs/etc/start_blog">ETC</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">Index</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/kotlin/release/kotlin_1.6">Kotlin 릴리즈 노트</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/kotlin/coroutine/coroutine_context_and_dispatchers">Coroutine</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/kotlin/coroutine/coroutine_context_and_dispatchers">Coroutine context and dispatchers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/kotlin/coroutine/asyncronous_flow">Asynchronous Flow</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Coroutine context and dispatchers</h1></header><p>코루틴은 여러 유형들이 CoroutineContext가 있으며, 이것이 제공하는 context에서 실행 됩니다.</p><p>context는 여러 요소의 집합인데, 주 요소는 코루틴의 Job과 Dispatcher가 있습니다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="dispatchers-and-threads"><strong>Dispatchers and threads</strong><a aria-hidden="true" class="hash-link" href="#dispatchers-and-threads" title="Direct link to heading">​</a></h2><p>코루틴 디스패처는 코루틴 실행을 특정 스레드로 제한하거나 스레드 풀에 디스패치하거나 제한 없이 실행되도록 할 수 있습니다.</p><p><code>launch</code> 및 <code>async</code>와 같은 모든 코루틴 빌더는 새 코루틴 및 기타 컨텍스트 요소에 대한 디스패처를 지정하는  CoroutineContext 매개변수를 허용합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">launch { // context of the parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;main runBlocking      : I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">launch(Dispatchers.Unconfined) { // not confined -- will work with main thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Unconfined            : I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Default               : I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) { // will get its own new thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;newSingleThreadContext: I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Unconfined            : I&#x27;m working in thread main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Default               : I&#x27;m working in thread DefaultDispatcher-worker-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">newSingleThreadContext: I&#x27;m working in thread MyOwnThread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main runBlocking      : I&#x27;m working in thread main</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>launch</code>가 매개변수 없이 사용되면 시작되는 CoroutineScope의 컨텍스트(디스패처)를 상속합니다.</p><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" target="_blank" rel="noopener noreferrer"><code>Dispatchers.Unconfined</code></a>는 메인 스레드에서도 실행되는 것처럼 보이지만 실제로는 특수한 디스패처로서 뒤에 설명됩니다.</p><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" target="_blank" rel="noopener noreferrer"><code>Dispatchers.Default</code></a>는 스코프에 명확히 선언 할 디스패처가 없을 때 사용합니다. 이것은 공유 백그라운드 스레드를 사용합니다.</p><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html" target="_blank" rel="noopener noreferrer"><code>newSingleThreadContext</code></a>는 코루틴이 실행할 스레드를 개별적으로 생성합니다. 전용 스레드는 비용이 큰 리소스입니다. 더 이상 필요하지 않을 때 <code>close</code> 기능을 사용하여 해제하거나 최상위 변수에 저장하고 프로그램 전체에서 재사용해야 합니다.</p><p>이것은 구식 API이며 <code>Executors.newSingleThreadExecutor().asCoroutineDispatcher()</code>를 사용하며 관리됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">CoroutineScope(Dispatchers.IO).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Log.e(&quot;CCOOVV&quot;, &quot;IO1 work1 called ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CoroutineScope(Dispatchers.IO).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Log.e(&quot;CCOOVV&quot;, &quot;IO2 work1 called ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CoroutineScope(Executors.newSingleThreadExecutor().asCoroutineDispatcher()).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Log.e(&quot;CCOOVV&quot;, &quot;Custom work1 called ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">2021-11-06 16:43:36.570 9373-9474/ IO2 work1 called DefaultDispatcher-worker-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2021-11-06 16:43:36.574 9373-9477/ IO1 work1 called DefaultDispatcher-worker-4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2021-11-06 16:43:37.563 9373-9479/ Custom work1 called pool-1-thread-1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="unconfined-vs-confined-dispatcher"><strong>Unconfined vs confined dispatcher</strong><a aria-hidden="true" class="hash-link" href="#unconfined-vs-confined-dispatcher" title="Direct link to heading">​</a></h2><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" target="_blank" rel="noopener noreferrer"><code>Dispatchers.Unconfined</code></a>는 호출한 스레드에서 실행되는 코루틴 디스패처 입니다. 단, 중단 함수를 만나기 전까지만 동작합니다. 중단 함수를 만나고 복귀했을 때는 중단 함수에서 실행된 쓰레드에서 계속 실행됩니다.</p><p>이 디스패처는 CPU 시간을 소비하지 않는 장점이 있습니다. 하지만 특정 쓰레드에 국한된 공유 데이터를 갱신하지 않는 코루틴에 적합합니다.</p><p>반면에 디스패처는 기본적으로 외부 CoroutineScope에서 상속됩니다. runBlocking 코루틴에 대한 기본 디스패처는 호출자 스레드로 제한되므로 이를 상속하면 예측 가능한 FIFO 스케줄링으로 실행을 이 스레드로 제한하는 효과가 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">launch(Dispatchers.Unconfined) { // not confined -- will work with main thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Unconfined      : I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(500)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Unconfined      : After delay in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">launch { // context of the parent, main runBlocking coroutine</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;main runBlocking: I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;main runBlocking: After delay in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Unconfined      : I&#x27;m working in thread main @coroutine#2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main runBlocking: I&#x27;m working in thread main @coroutine#3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor @coroutine#2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main runBlocking: After delay in thread main @coroutine#3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>비제한 디스패처는 일부 작업이 즉시 수행되어야 하기 때문에 나중에 실행을 위해 코루틴을 디스패치할 필요가 없거나 사이드 이펙트가 발생하는 특정 케이스에 도움이 될 수 있는 고급 메커니즘입니다. 비제한 디스패처는 일반 코드에서 사용하면 안 됩니다.</strong></p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="jumping-between-threads"><strong>Jumping between threads</strong><a aria-hidden="true" class="hash-link" href="#jumping-between-threads" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">newSingleThreadContext(&quot;Ctx1&quot;).use { ctx1 -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newSingleThreadContext(&quot;Ctx2&quot;).use { ctx2 -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        runBlocking(ctx1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(&quot;Started in ctx1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            withContext(ctx2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log(&quot;Working in ctx2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log(&quot;Back to ctx1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">[Ctx1 @coroutine#1] Started in ctx1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Ctx2 @coroutine#1] Working in ctx2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Ctx1 @coroutine#1] Back to ctx1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>위에는 몇가지 기술을 보여줍니다. 하나는 명시적으로 지정된 컨텍스트와 함께 runBlocking을 사용하는 것이고 다른 하나는 아래 출력에서 볼 수 있듯이 동일한 코루틴에 계속 유지하면서 withContext 함수를 사용하여 코루틴의 컨텍스트를 변경하는 것입니다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="job-in-the-context"><strong>Job in the context</strong><a aria-hidden="true" class="hash-link" href="#job-in-the-context" title="Direct link to heading">​</a></h2><p>코루틴의 <code>Job</code>은 context의 일부이고, 다음과 같이 조회할 수 있습니다.</p><p><code>coroutineContext[Job]</code></p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val job = CoroutineScope(Dispatchers.Unconfined).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delay(10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;My job is &quot; + coroutineContext[job.key])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">My job is &quot;coroutine#1&quot;:BlockingCoroutine{Active}@32a1bec0</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="children-of-a-coroutine"><strong>Children of a coroutine</strong><a aria-hidden="true" class="hash-link" href="#children-of-a-coroutine" title="Direct link to heading">​</a></h2><p>다른 코루틴의 스코프 안에서 코루틴이 실행되면 컨텍스트를 물려받고 새로운 코루틴의 잡은 부모 코루틴의 잡의 자식으로 시작됩니다. 부모 코루틴이 취소되면 모둔 자식들도 취소됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val scope = CoroutineScope(Dispatchers.IO)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val parentJob = scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;parent start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val childJob = launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;child start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>그러나 부모-자식 관계는 다음 두가지 방법 중 하나로 재정의될 수 있습니다.</p><ol><li><p>코루틴을 시작할 때 다른 스코프로 실행되면(예: GlobalScope.launch) 상위 스코프에서 Job을 상속하지 않습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val scope = CoroutineScope(Dispatchers.IO)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val parentJob = scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;parent start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val isNotChildJob = CoroutineScope(Dispatchers.IO).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;is not child start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><p>다른 Job 객체가 새 코루틴에 대한 컨텍스트로 전달되면 상위 범위의 Job을 재정의합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val scope = CoroutineScope(Dispatchers.IO)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val parentJob = scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;parent start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val isNotChildJob = launch(Job()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;is not child start&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ol><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="parental-responsibilities"><strong>Parental responsibilities</strong><a aria-hidden="true" class="hash-link" href="#parental-responsibilities" title="Direct link to heading">​</a></h2><p>부모 코루틴은 항상 모든 자식 작업이 완료되기를 기다립니다. 부모는 시작하는 모든 자식을 명시적으로 추적할 필요가 없으며 마지막에 자식을 기다리기 위해 Job.join을 사용할 필요도 없습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// launch a coroutine to process some kind of incoming request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val request = launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    repeat(3) { i -&gt; // launch a few children jobs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        launch  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;Coroutine $i is done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;request: I&#x27;m done and I don&#x27;t explicitly join my children that are still active&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">request.join() // wait for completion of the request, including all its children</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Now processing of the request is complete&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">request: I&#x27;m done and I don&#x27;t explicitly join my children that are still active</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coroutine 0 is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coroutine 1 is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coroutine 2 is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Now processing of the request is complete</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="combining-context-elements"><strong>Combining context elements</strong><a aria-hidden="true" class="hash-link" href="#combining-context-elements" title="Direct link to heading">​</a></h2><p>때때로 우리는 코루틴 컨텍스트의 여러 요소를 정의할 필요가 있다.</p><p><code>+</code> 오퍼레이터를 사용하여 정의 가능하다.</p><p>예를들어 코루틴을 실행할 때 Dispatcher를 정의하고 코루틴의 이름을 적의하고 싶을 때 다음과 같이 적용할 수 있다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;I&#x27;m working in thread ${Thread.currentThread().name}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">I&#x27;m working in thread DefaultDispatcher-worker-1 @test#2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="coroutine-scope"><strong>Coroutine scope</strong><a aria-hidden="true" class="hash-link" href="#coroutine-scope" title="Direct link to heading">​</a></h2><p>Context, children, Job 의 정보를 합쳐 봅시다. 어플리케이션에 수명 주기가 있는 객체가 있고, 그 객체는 코루틴이 아니라고 가정해봅시다. 예를 들어, 안드로이드 애플리케이션을 작성하고 데이터를 가져오고, 업데이트하고, 애니메이션을 처리하는 등의 비동기 작업을 하기 위해 액티비티 컨텍스트에서 다양한 코루틴을 시작합니다. 모든 코루틴은 메모리 누수를 방지하기 위해 액티비티가 파괴되면 모두 취소되어야 합니다.</p><p>물론 Context와 Job을 직접 조작하여 액티비티와 코루틴의 수명 주기를 연결할 수 있지만, kotlinx.coroutines는 CoroutineScope를 캡슐화하는 추상화를 제공합니다. 모든 코루틴 빌더가 확장함수로 선언되므로 코루틴 스코프에 익숙해져야 합니다.</p><p>우리는 액티비티의 생명주기에 연결된 CoroutineScope 인스턴스를 생성하여 코루틴 생명주기를 관리합니다. SoroutineScope 인스턴스는 CoroutineScope() 또는 MainScope() 팩토리 함수로 생성할 수 있습니다. 전자는 범용 범위를 생성하고 후자는 Dispatchers.Main 디스패처를 사용하여 UI 애플리케이션을 위한 Scope를 생성합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Activity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val mainScope = MainScope()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun destroy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mainScope.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>정의한 코루틴 스코프에서 코루틴을 실행 할 수 있습니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun doSomething() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // launch ten coroutines for a demo, each working for a different time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    repeat(10) { i -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mainScope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println(&quot;Coroutine $i is done&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>액티비티가 생성된 후에 함수를 실행하고, 500ms 후에 액티비티를 파괴하는 경우 함수는 중단됩니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">val activity = Activity()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">activity.doSomething() // run test function</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Launched coroutines&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">delay(500L) // delay for half a second</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Destroying activity!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">activity.destroy() // cancels all coroutines</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">delay(1000) // visually confirm that they don&#x27;t work</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Launched coroutines</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coroutine 0 is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coroutine 1 is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Destroying activity!</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>안드로이드에서는 first-party로 생명주기에 대한 코루틴 스코프를 지원하고 있습니다.</p><p><a href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope" target="_blank" rel="noopener noreferrer">https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope</a></p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="thread-local-data"><strong>Thread-local data</strong><a aria-hidden="true" class="hash-link" href="#thread-local-data" title="Direct link to heading">​</a></h3><p>코루틴간에 혹은 스레드 로컬간에 데이터를 간편하게 전달할 수 있습니다.</p><p>그러나 특정 스레드에 바인딩되지 않기 때문에 수동으로 수행하면 보일러플레이트로 이어질 수 있습니다.</p><p>이를 위해 ThreadLocal은 asContextElement 확장 함수가 있습니다. 주어진 ThreadLocal의 값을 유지하고 코루틴이 컨텍스트를 전환할 때마다 이를 복원하는 추가 컨텍스트 요소를 생성합니다.</p><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() = runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val threadLocal = ThreadLocal&lt;String&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threadLocal.set(&quot;main&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Pre-main, current thread: ${Thread.currentThread()}, thread local value: &#x27;${threadLocal.get()}&#x27;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;Launch start, current thread: ${Thread.currentThread()}, thread local value: &#x27;${threadLocal.get()}&#x27;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        yield()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;After yield, current thread: ${Thread.currentThread()}, thread local value: &#x27;${threadLocal.get()}&#x27;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    job.join()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Post-main, current thread: ${Thread.currentThread()}, thread local value: &#x27;${threadLocal.get()}&#x27;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-kotlin"><div class="codeBlockContent_hGly kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#x27;main&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: &#x27;launch&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">After yield, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: &#x27;launch&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: &#x27;main&#x27;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>위 예제에서는 새로운 코루틴을 Dispatcher.Default의 백그라운드 스레드 풀을 사용하였기 때문에 다른 스레드에서 동작하였습니다. 하지만 코루틴이 실행되는 스레드에 관계없이 <code>threadLocal.asContextElement(value = &quot;launch&quot;)</code>를 사용하여 thread local 변수는 여전히 존재합니다.</p><p>이 컨텍스트 요소를 설정하는 것을 잊혀지기 쉽습니다. 코루틴을 실행하는 스레드가 다른 경우 액세스하는 스레드 로컬 변수에 예기치 않은 값이 있을 수 있습니다. 이러한 상황을 피하려면 surePresent 메서드와 fail-fast를 사용하는 것을 추천합니다.</p><p>ThreadLocal은 최고 수준의 지원을 제공하며 모든 기본 kotlinx.coroutines가 제공하는 것과 함께 사용할 수 있습니다. 그러나 한 가지 주요 제한 사항이 있습니다. 스레드 로컬이 변경되면 새 값이 코루틴 호출자에게 전파되지 않고 업데이트된 값이 다음 일시 중단 시 손실됩니다.(컨텍스트 요소가 모든 ThreadLocal 개체 액세스를 추적할 수 없기 때문에)</p><p>withContext를 사용하여 코루틴에서 스레드 로컬 값을 업데이트하세요. 자세한 내용은 asContextElement를 참조하세요.</p><p>또는 Counter(var i: Int) 클래스와 같은 mutable box에 값을 저장할 수 있으며, 이는 차례로 스레드 로컬 변수에 저장됩니다. 그러나 이 경우 mutable box에 대한 잠재적인 동시성 문제에 대해서는 개별적인 처리가 필요합니다.</p><p>다음과 같은 고급 사용법으로서는 구현해야 하는 ThreadContextElement 인터페이스의 문서를 참조하십시오. (로깅 MDC, 트랜잭션 컨텍스트, 데이터 전달을 위해 내부적으로 스레드 로컬을 사용하는 기타 라이브러리와의 통합)</p></div></article><div class="comment-container"></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#dispatchers-and-threads" class="table-of-contents__link toc-highlight"><strong>Dispatchers and threads</strong></a></li><li><a href="#unconfined-vs-confined-dispatcher" class="table-of-contents__link toc-highlight"><strong>Unconfined vs confined dispatcher</strong></a></li><li><a href="#jumping-between-threads" class="table-of-contents__link toc-highlight"><strong>Jumping between threads</strong></a></li><li><a href="#job-in-the-context" class="table-of-contents__link toc-highlight"><strong>Job in the context</strong></a></li><li><a href="#children-of-a-coroutine" class="table-of-contents__link toc-highlight"><strong>Children of a coroutine</strong></a></li><li><a href="#parental-responsibilities" class="table-of-contents__link toc-highlight"><strong>Parental responsibilities</strong></a></li><li><a href="#combining-context-elements" class="table-of-contents__link toc-highlight"><strong>Combining context elements</strong></a></li><li><a href="#coroutine-scope" class="table-of-contents__link toc-highlight"><strong>Coroutine scope</strong></a><ul><li><a href="#thread-local-data" class="table-of-contents__link toc-highlight"><strong>Thread-local data</strong></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 COV. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.83ea7414.js"></script>
<script src="/assets/js/main.e2d59c23.js"></script>
</body>
</html>