<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">3장 코드의 구린내 | COV</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hscodev.github.io/docs/etc/refactoring/03"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="3장 코드의 구린내 | COV"><meta data-react-helmet="true" name="description" content="리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링을 적용하는 것 만큼 중요하다. 하지만 이것은 인스턴스 변수를 없애거나 계층 구조를 작성하는 방법에 대해서는 설명하기 쉽지만 시점에 대한 내용은 설명하기 어렵다."><meta data-react-helmet="true" property="og:description" content="리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링을 적용하는 것 만큼 중요하다. 하지만 이것은 인스턴스 변수를 없애거나 계층 구조를 작성하는 방법에 대해서는 설명하기 쉽지만 시점에 대한 내용은 설명하기 어렵다."><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hscodev.github.io/docs/etc/refactoring/03"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/03" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/03" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4d477d3e.css">
<link rel="preload" href="/assets/js/runtime~main.71916ec2.js" as="script">
<link rel="preload" href="/assets/js/main.6ae0c4c9.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">COV</b></a><a class="navbar__item navbar__link" href="/docs/">Kotlin</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/etc/start_blog">ETC</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/etc/start_blog">개발자 개인 블로그를 제작해보자.</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/etc/essence_of_oop/01">객체지향의 사실과 오해</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/etc/refactoring/01">리팩토링</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/01">1장 맛보기 예제</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/02">2장 리팩토링 개론</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/etc/refactoring/03">3장 코드의 구린내</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/04">4장 테스트 작성</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/05">5장 리팩토링 기법 카탈로그에 대해</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_2fq0" tabindex="0" href="/docs/etc/refactoring/06/06-overview">6장 메서드 정리</a><button aria-label="Toggle the collapsible sidebar category &#x27;6장 메서드 정리&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>3장 코드의 구린내</h1></header><p>리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링을 적용하는 것 만큼 중요하다. 하지만 이것은 인스턴스 변수를 없애거나 계층 구조를 작성하는 방법에 대해서는 설명하기 쉽지만 시점에 대한 내용은 설명하기 어렵다.</p><p>이 장에서는 시점이나 상황에 대해 정확한 기준을 제시하지는 않는다. 사람의 직감이 가장 뛰어난 기준이라고 생각한다. 적어도 표를 참고하여 방향 만큼은 제대로 잡게 될 것이다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="중복-코드">중복 코드<a aria-hidden="true" class="hash-link" href="#중복-코드" title="Direct link to heading">​</a></h2><p>똑같은 코드 구조가 두 군데 이상 있을 때는 통합 했을 때 프로그램이 개선된다.</p><p><strong>한 클래스의 두 메서드 안에 같은 코드가 있는 경우</strong></p><ul><li><strong>메서드 추출 기법</strong>을 적용하여 별도의 메서드를 만든다.</li></ul><p><strong>두 하위 클래스에 같은 코드가 들어있는 경우</strong></p><ul><li><strong>메서드 추출 기법</strong>을 적용한 후 <strong>메서드 상향 기법</strong>을 적용한다.</li></ul><p><strong>같지 않고 비슷하다면</strong></p><ul><li><strong>메서드 추출</strong>로 다른 부분을 분리한다. 그 후 <strong>템플릿 메서드 형성 기법</strong>을 적용해야 할 수도 있다.</li></ul><p><strong>알고리즘만 다르고 기능이 같다면</strong></p><ul><li>알고리즘 중 더 간단한 것을 택해 <strong>알고리즘 전환</strong>을 적용한다.</li></ul><p><strong>중복 코드가 메서드 가운데 있다면</strong></p><ul><li>주변 <strong>메서드 추출</strong>을 적용 한다.</li></ul><p><strong>서로 상관 없는 두 클래스 안에 중복 코드가 있을 때</strong></p><ul><li>한 클래스의 중복 코드를 <strong>클래스 추출</strong>이나 <strong>모듈 추출</strong>을 적용해 제 3의 클래스나 모듈로 뗴어낸다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="장황한-메서드">장황한 메서드<a aria-hidden="true" class="hash-link" href="#장황한-메서드" title="Direct link to heading">​</a></h2><p>장수하는 객체 프로그램은 고통적으로 메서드 길이가 짧다. 프로그래밍 개념이 생겨났을 때부터 프로시저가 길수록 이해하기 어렵다는 점을 알았다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="메서드-쪼개기">메서드 쪼개기<a aria-hidden="true" class="hash-link" href="#메서드-쪼개기" title="Direct link to heading">​</a></h3><p><strong>메서드를 줄이려면</strong></p><ul><li>대부분 <strong>메서드 추출 기법</strong>을 적용한다.</li></ul><p><strong>매개변수와 임시변수가 많으면 메서드 추출이 어렵다.</strong></p><ul><li><strong>임시 변수를 메서드 호출로 전환 기법</strong>이나 <strong>임시변수를 메서드 체인으로 전환기법</strong>을 적용하면 임시변수가 제거된다.</li></ul><p><strong>길게 열거된 매개변수는</strong></p><ul><li><strong>매개변수 세트를 객체로 전환 기법</strong>과 <strong>객체를 통째로 전달 기법</strong>을 적용하면 간결해진다.</li></ul><p><strong>여전히 임시변수와 매개변수가 너무 많을때는</strong></p><ul><li><strong>메서드를 메서드 객체로 전환 기법</strong>을 적용하면 된다.</li></ul><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="조건문과-루프도-역시-메서드로-빼야한다">조건문과 루프도 역시 메서드로 빼야한다.<a aria-hidden="true" class="hash-link" href="#조건문과-루프도-역시-메서드로-빼야한다" title="Direct link to heading">​</a></h3><p><strong>조건문을 추출하려면</strong></p><ul><li><strong>조건문 쪼개기 기법</strong>을 사용한다.</li></ul><p><strong>루프를 추출하려면</strong></p><ul><li><strong>컬렉션 클로저 메서드로 전환</strong>을 실시한 후 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시하면 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="방대한-클래스">방대한 클래스<a aria-hidden="true" class="hash-link" href="#방대한-클래스" title="Direct link to heading">​</a></h2><p>기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어있다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="인스턴스가-많은-경우-중복-코드가-반드시-존재하기-마련이다">인스턴스가 많은 경우 중복 코드가 반드시 존재하기 마련이다.<a aria-hidden="true" class="hash-link" href="#인스턴스가-많은-경우-중복-코드가-반드시-존재하기-마련이다" title="Direct link to heading">​</a></h3><p><strong>클래스 추출</strong>을 실시하여 수많은 인스턴스 변수를 하나로 묶을 수 있다. 서로 연관된 변수를 골라서 클래스로 빼내는 것이다. 보통 변수의 접두어나 접미어가 같다면 하나의 클래스로 추출하기 좋다.</p><p>e.g.) depositAmount, depositCurrency</p><p><strong>하위 클래스로 추출하는 것이 적합할 것 같으면</strong></p><ul><li><strong>하위 클래스 추출</strong>을 실시하는 것이 더 간단하다.</li></ul><p><strong>추출할 클래스가 대리자로 부적절 할 것 같다면</strong></p><ul><li><strong>모듈 추출</strong>을 실시하면 된다.</li></ul><p><strong>인스턴스 변수가 계속해서 사용되지 않는 경우</strong></p><ul><li><strong>클래스 추출, 모듈 추출, 하위 클래스 추출</strong> 중 하나를 여러번 적용하는 방법도 있다.</li></ul><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="코드-분량이-너무-방대한-클래스에도-중복-코드가-많이-있기-마련이다">코드 분량이 너무 방대한 클래스에도 중복 코드가 많이 있기 마련이다.<a aria-hidden="true" class="hash-link" href="#코드-분량이-너무-방대한-클래스에도-중복-코드가-많이-있기-마련이다" title="Direct link to heading">​</a></h3><p><strong>코드 분량이 방대한 클래스에서도</strong></p><ul><li><strong>클래스 추출, 모듈 추출, 하위 클래스 추출</strong> 중 하나를 실시할 수 있다.</li></ul><p><strong>클래스의 사용 방법이 결정된다면</strong></p><ul><li><strong>인터페이스 추출</strong>을 실시할 수도 있다.</li></ul><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="방대한-클래스가-gui인-경우">방대한 클래스가 GUI인 경우<a aria-hidden="true" class="hash-link" href="#방대한-클래스가-gui인-경우" title="Direct link to heading">​</a></h3><p>데이터와 기능을 서로 다른 도메인에 객체를 옮기자</p><ul><li>두 도메인의 데이터의 싱크를 맞추어야 할 수 있는데, <strong>관측 데이터 복제 기법</strong>을 실시할 수 있다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="과다한-매개변수">과다한 매개변수<a aria-hidden="true" class="hash-link" href="#과다한-매개변수" title="Direct link to heading">​</a></h2><p>객체지향의 등장으로 데이터는 객체에 요청할 수 있게 되었다. 매개변수 세트가 구식 프로그램에 비해 훨씬 간결하다. 매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편해지고, 더 많은 데이터가 필요해질 때마다 계속 수정해야 하기 때문에 매개변수들을 이해하기가 힘들다.</p><p><strong>객체에 요청하여 매개변수에 들어있는 데이터를 가져올 때는</strong></p><ul><li><strong>매개변수 세트를 메서드</strong>로 전환을 적용하면 된다.</li></ul><p><strong>객체에 있는 데이터 세트를 객체 자체로 전환하려면</strong></p><ul><li><strong>객체를 통째로 전달</strong>을 적용하면 된다.</li></ul><p><strong>여러 데이터 항목에 논리적 객체가 없다면</strong></p><ul><li><strong>매개변수 세트를 객체로 전환</strong>을 적용하면 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="수정의-산발">수정의 산발<a aria-hidden="true" class="hash-link" href="#수정의-산발" title="Direct link to heading">​</a></h2><p>수정할 때 개발자는 분명한 위치에서 수정할 수 있어야 한다. 반대로 <strong>한 클래스가 다양한 원인으로 다양한 방식으로 자주 수정될 때 문제가 발생한다.</strong></p><p>예를 들어 새 데이터 베이스를 생성할 때마다 3개의 메서드를 수정하거나 금융 상품을 수정할 때 4개의 메서드를 수정해야할 때이다. 이럴 때는 클래스를 여러개의 객체로 분리하여 한 종류에 하나의 객체만 수정되게 해야한다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="기능의-산재">기능의 산재<a aria-hidden="true" class="hash-link" href="#기능의-산재" title="Direct link to heading">​</a></h2><p>수정의 산발과 비슷하지만 정 반대이다. <strong>수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다.</strong> 수정할 부분을 찾기 힘들며 꼭 수정해야 할 부분도 놓치기 쉽다.</p><ul><li><strong>메서드 이동</strong>과 <strong>필드 이동</strong>을 이용하여 <strong>수정할 부분들은 전무 하나의 클래스 안에 넣어야 한다.</strong></li><li><strong>클래스에 넣기에 부적절 할때는</strong> 새로운 클래스를 만들어야 한다.</li><li>대게는 <strong>클래스 내용 직접 삽입</strong>을 통해 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="잘못된-소속">잘못된 소속<a aria-hidden="true" class="hash-link" href="#잘못된-소속" title="Direct link to heading">​</a></h2><p>전통적으로 한 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 소속을 의심할 수 있다.</p><ul><li><strong>메서드 이동 기법</strong>을 실시하여 더 자주 접근하는 클래스로 옮기자.</li><li>메서드 일부만 소속이 잘못된 경우 <strong>메서드 추출</strong>과 <strong>메서드 이동</strong>을 적용하여 적절한 클래스로 옮길 수 있다.</li></ul><p>전략 패턴과 방문자 패턴, 자가 위임 패턴처럼 이 규칙을 따르지 않는 복잡한 패턴도 일부 있다. 이 패턴들은 수정의 산발이 의심될 대 해결책으로 쓰인다. 기본 규칙은 함께 수정되는 것들을 하나로 뭉치는 것이다. 단, 기능을 수정하기는 쉬워지지만 인다이렉션이 늘어나는 단점이 있을 수 있다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="데이터-뭉치">데이터 뭉치<a aria-hidden="true" class="hash-link" href="#데이터-뭉치" title="Direct link to heading">​</a></h2><p>두 클래스에 들어있는 인스턴스 변수나 여러 메서드 시그니처에 들어있는 매개변수처럼 동일한 3~4개의 데이터 항목이 여러 위치에 몰려있는 경우가 많다. <strong>이러한 데이터 뭉치는 객체로 만들어야 한다.</strong></p><p><strong>이 뭉치를 객체로 전환하려면</strong></p><ul><li>필드들을 대상으로 <strong>클래스 추출 기법</strong>을 사용할 수 있다.</li></ul><p><strong>메서드 시그니처를 대상으로 간결하게 하려면</strong></p><ul><li><strong>매개변수 세트를 객체로 전환 기법</strong>과 <strong>객체를 통째로 전달 기법</strong>을 적용할 수 있다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="강박적-기본-타입-사용">강박적 기본 타입 사용<a aria-hidden="true" class="hash-link" href="#강박적-기본-타입-사용" title="Direct link to heading">​</a></h2><p>객체를 처음 접하는 사람은 보통 숫자와 통화를 연동하는 돈 관련 클래스나 전화번호와 우편번호같은 특수 문자열 클래스 등의 사소한 작업에 작은 객체를 잘 사용하지 않으려는 경향이 있다.</p><p><strong>데이터 값을 객체로 전환 기법</strong>을 이용해 우물 안 개구리를 벗어나자.</p><p><strong>데이터 값이 분류 부호일 땐 그 값이 기능에 영향을 주지 않는다면</strong></p><ul><li><strong>분류 부호를 클래스로 전환 기법</strong>을 사용할 수 있다.</li></ul><p><strong>조건문에 분류 부호가 사용될 땐</strong></p><ul><li><strong>분류 부호를 하위클래스로 전환 기법</strong>이나 <strong>분류 부호를 상태/전략 패턴으로 전환 기법</strong>을 사용할 수 있다.</li></ul><p><strong>뭉쳐다녀야 할 여러 개의 필드가 있는 경우</strong></p><ul><li><strong>클래스 추출 기법</strong>을 적용해야 한다.</li></ul><p><strong>기본 타입이 매개변수 세트에 들어 있다면</strong></p><ul><li><strong>매개변수 세트를 객체로 전환 기법</strong>을 적용하면 된다.</li></ul><p><strong>배열 때문에 불편하다면</strong></p><ul><li><strong>배열을 객체로 전환 기법</strong>을 적용하면 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="switch문">Switch문<a aria-hidden="true" class="hash-link" href="#switch문" title="Direct link to heading">​</a></h2><p>객체지향 코드의 확연한 특징 중 하나는 switch문이 비교적 적게 사용된다는 점이다. switch문은 반드시 중복이 생기기 마련이다. 다형성, 즉 재정의로 해결할 수 있다. 대부분의 switch 문은 고민할 필요 없이 재정의로 바꾸어야 한다.</p><p><strong>switch 문에는 분류 부호가 흔히 사용되는데,</strong></p><ul><li><strong>메서드 추출을 실시</strong>해서 switch문을 메서드로 빼낸 후 <strong>메서드 이동</strong>을 실시해서 메서드를 재정의해야 할 클래스로 옮겨 넣어 <strong>분류 부호 값을 메서드나 클래스로 분류한다</strong>.</li><li>그와 동시에 <strong>분류 부호를 하위 클래스로 전환 기법</strong>과 <strong>분류 부호를 상태/전략 패턴으로 전환 기법</strong> 중 어느 것을 적용할지 판단해야 한다.</li></ul><p><strong>상속 구조가 만들어졌다면</strong></p><ul><li><strong>조건문을 재정의로 전환 기법</strong>을 적용한다.</li></ul><p><strong>하나의 메서드에 영향을 미치는 case 문이 2~3개 밖에 없고 나중에 모든 case 문을 수정할 일이 없다면 재정의로 전환하는 것은 과하다.</strong></p><ul><li>그럴 때는 <strong>매개변수를 메서드로 변환</strong>을 적용하는 편이 낫다.</li></ul><p><strong>조건문이 들어있는 여러 case문 중 하나가 널 일때는</strong></p><ul><li><strong>널 검사를 걸 객체에 위임</strong>을 실시하면 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="평행-상속-계층">평행 상속 계층<a aria-hidden="true" class="hash-link" href="#평행-상속-계층" title="Direct link to heading">​</a></h2><p>평행 상속 계층의 문제점은 한 클래스의 하위 클래스를 만들 때마다 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 의심해 볼 수 있다.</p><p>중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만들면 된다. <strong>메서드 이동</strong>과 <strong>필드 이동</strong>을 실시하면 참조하는 클래스에 있는 계층이 제거된다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="직무유기-클래스">직무유기 클래스<a aria-hidden="true" class="hash-link" href="#직무유기-클래스" title="Direct link to heading">​</a></h2><p>하나의 클래스는 유지관리와 이해하기 위한 비용이 발생한다. 따라서 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 없애야 한다.</p><p>리팩토링으로 인해 기능이 축소된 클래스, 수정을 계획하여 작성했으나 수정을 하지 않아 쓸모없어진 클래스가 해당한다.</p><p><strong>비용 대비 효율이 떨어지는 하위 클래스나 모듈은</strong></p><ul><li><strong>계층 병합</strong>을 실시한다.</li></ul><p><strong>거의 쓸모없는 구성 요소는</strong></p><ul><li><strong>클래스 내용 직접 삽입</strong>이나 <strong>모듈 내용 직접 삽입</strong> 기법을 적용한다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="막연한-범용-코드">막연한 범용 코드<a aria-hidden="true" class="hash-link" href="#막연한-범용-코드" title="Direct link to heading">​</a></h2><p>막연한 생각에 아직은 필요 없는 기능을 수행하고자 온갖 호출과 case문을 넣으려 하는 순간 막연한 범용 코드가 생긴다. 대체로 코드를 알아보고 유지보수 하기가 어려워진다.</p><p>메서드나 클래스가 테스트 케이스를 위해 사용되는 것도 막연한 범용 코드의 한 종류이다.</p><p><strong>별다른 기능이 없는 클래스나 모듈이 있다면</strong></p><ul><li><strong>계층 병합</strong>을 실시할 수 있다.</li></ul><p><strong>불필요함 위임을 제거하려면</strong></p><ul><li><strong>클래스 내용 직접 삽입</strong>을 실시할 수 있다.</li></ul><p><strong>메서드에 사용되지 않는 매개변수가 있으면</strong></p><ul><li><strong>매개변수 제거</strong>를 실시할 수 있다.</li></ul><p><strong>메서드명이 이상하다면</strong></p><ul><li><strong>메서드명 변경</strong>을 실시할 수 있다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="임시-필드">임시 필드<a aria-hidden="true" class="hash-link" href="#임시-필드" title="Direct link to heading">​</a></h2><p>객체 안에서 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다. 개발자는 모든 변수를 이용하리라 생각하기 마련이므로 이런 코드는 알아채기 힘들다.</p><p><strong>이런 떠돌이 변수들을 정리해 주기 위해</strong></p><ul><li><strong>클래스 추출</strong>을 실시할 수 있다.</li></ul><p><strong>이 클래스에서 변수 값들이 올바르지 않을 경우를 대비해</strong></p><ul><li><strong>널 검사를 널 객체에 위임</strong>을 실시하여  경우에 따라 조건문 코드를 없앨 수 있다.</li></ul><p>임시 필드의 문제는 <strong>보통 복잡한 알고리즘에 여러 변수를 사용할 때도 나타난다.</strong></p><ul><li>이럴 때는 인스턴스 변수와 그 변수를 사용하는 메서드 전부에 대해 <strong>클래스 추출</strong>을 적용한다.</li><li>그러면 메서드 객체가 새로 생성된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="메시지-체인">메시지 체인<a aria-hidden="true" class="hash-link" href="#메시지-체인" title="Direct link to heading">​</a></h2><p>메시지 체인은 한 객체에 요청을 보내면 제 2의 객체가 3의 객체로 3의 객체가 4의 객체로 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 말한다.</p><p>이럴 때는 <strong>대리 객체 은폐</strong>를 실시해야 한다. 원칙적으로 체인 구성을 하는 모든 객체에 적용할 수 있지만, 그렇게 하면 모든 중간 객체가 중개 메서드로 변해서 <strong>과잉 중개 메서드</strong>의 구린내를 풍기는 문제가 흔히 발생한다. 그에 따라 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 나을 수 있다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="과잉-중개-메서드">과잉 중개 메서드<a aria-hidden="true" class="hash-link" href="#과잉-중개-메서드" title="Direct link to heading">​</a></h2><p>객체지향에서 캡슐화가 너무 지나치면 문제가 될 수도 있다.</p><p><strong>인터페이스에서 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면</strong>,</p><ul><li><strong>과잉 중개 메서드 제거</strong>를 실시하여 원리가 구현된 객체에 직접 접근하자.</li></ul><p><strong>일부 메서드에 별 기능이 없다면</strong></p><ul><li><strong>메서드 내용 직접 삽입</strong>을 실시해서 메서드들의 내용을 호출 객체에 직접 삽입하면 된다.</li></ul><p>부수적인 기능이 있다면</p><ul><li><strong>위임을 상속으로 전환 기법</strong>을 실시하여 중개 메서드를 실제 객체의 하위 클래스로 전환하면 된다.</li></ul><p>이렇게 하면 모든 위임을 추적하지 않고 기능을 확장할 수 있다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="지나친-관여">지나친 관여<a aria-hidden="true" class="hash-link" href="#지나친-관여" title="Direct link to heading">​</a></h2><p>클래스의 관계가 지나치게 밀접한 경우 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. <strong>클래스는 엄격하고 절제된 규칙을 따라야 한다.</strong></p><p><strong>메서드 이동</strong>과 <strong>필드 이동</strong>을 실시해서 각 클래스를 분리하여 <strong>지나친 관여를 줄여야 한다.</strong></p><p><strong>클래스들이 공통으로 필요한 부분이 있다면</strong></p><ul><li><strong>클래스의 양방향 연결을 단방향으로 전환 기법</strong>과 <strong>클래스 추출</strong>을 실시하여 안전한 클래스로 빼낸다.</li><li>아니면 <strong>대리 객체 은폐를 실시</strong>하여 다른 클래스가 중개 메서드 역할을 하게 만들어도 된다.</li></ul><p>하위 클래스가 상위 클래스가 공개하는 것 보다 많은 데이터를 필요로하는 것 처럼 상속으로 인해 지나친 관여가 발생하는 경우가 많다.</p><p><strong>상위 클래스에서 하위 클래스를 빼내야 할 경우에는</strong></p><ul><li><strong>상속을 위임으로 전환 기법</strong>을 적용해야 한다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="인터페이스가-다른-대용-클래스">인터페이스가 다른 대용 클래스<a aria-hidden="true" class="hash-link" href="#인터페이스가-다른-대용-클래스" title="Direct link to heading">​</a></h2><p><strong>기능은 같은데 시그니처가 다른 메서드에는</strong></p><ul><li><strong>메서드명 변경</strong>을 실시해야 한다.</li></ul><p><strong>클래스가 여전히 충분한 기능이 구현되어있지 않다면</strong></p><ul><li>프로토콜이 같아질 때까지 <strong>메서드 이동</strong>을 실시해서 기능을 해당 클래스로 옮겨야 한다.</li></ul><p><strong>코드를 너무 여러 번 옮겨야 한다면</strong></p><ul><li><strong>상위 클래스 추출</strong>을 실시하면 된다.</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="미흡한-라이브러리-클래스">미흡한 라이브러리 클래스<a aria-hidden="true" class="hash-link" href="#미흡한-라이브러리-클래스" title="Direct link to heading">​</a></h2><p>문제는 라이브러리 클래스를 원하는 기능을 수행하게 수정하는 것이 보통은 불가능한 것이다. 이 문제를 해결하기 위해 특수 목적의 기법이 두가지 있다.</p><p><strong>라이브러리 클래스에 넣어야 할 메서드가 두 개 뿐이라면</strong></p><ul><li><strong>외래 클래스에 메서드 추가 기법</strong>을 실시하고</li></ul><p><strong>부가 기능이 많을 때는</strong></p><ul><li><strong>국소적 상속확장 클래스 사용 기법</strong>을 실시하자</li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="데이터-클래스">데이터 클래스<a aria-hidden="true" class="hash-link" href="#데이터-클래스" title="Direct link to heading">​</a></h2><p>데이터 클래스는 데이터 보관만 담당하며, 구체적 데이터 조작은 다른 클래스가 수행한다.</p><p><strong>public 필드가 있다면</strong></p><ul><li><strong>필드 캡슐화 기법</strong>을 실시해야 한다.</li></ul><p><strong>컬렉션 필드가 캡슐화 되어있지 않다면</strong></p><ul><li><strong>컬렉션 캡슐화 기법</strong>을 적용하자</li></ul><p><strong>변경되지 않아야 하는 필드에는</strong></p><ul><li><strong>쓰기 메서드 제거</strong>를 적용하자.</li></ul><p><strong>다른 클래스에 의해 읽기 쓰기 메서드가 사용되는 부분이 있다면 다음 작업을 통해 최대한 은폐하자.</strong></p><ul><li><strong>메서드 이동</strong>을 실시하여 기능을 데이터 클래스로 옮긴다.</li></ul><p><strong>메서드 전체를 옮길 수 없다면</strong></p><ul><li><strong>메서드 추출</strong>을 실시해서 옮길 수 있는 메서드를 작성하면 된다.</li></ul><p>그 이후 <strong>메서드 은폐</strong>를 적용한다.</p><p>데이터 클래스는 성숙한 객체로서 역할을 하려면 어느정도의 책임을 감당해야 한다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="방치된-상속물">방치된 상속물<a aria-hidden="true" class="hash-link" href="#방치된-상속물" title="Direct link to heading">​</a></h2><p>하위 클래스에서 상속받은 메서드나 데이터가 더이상 쓰이지 않거나 필요 없을 땐 어떻게 해야할까. 보통 이런 경우 상속물을 전부 받아 필요한 것 외엔 방치해버리는 문제가 생긴다.</p><p>기존에는 이 문제의 원인이 잘못된 계층구조 때문이라고 설명했다. 이런 경우 새로운 대등 클래스를 작성하고 <strong>메서드 하향</strong>과 <strong>필드 하향</strong>을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아넣어 상위 클래스에는 공통 코드만 들어있게 한다.</p><p>그 외에는 일부 기능을 언제든 재사용하고자 하위클래스로 몰아넣는 작업을 하는데, 이 방법이 효과적임을 깨닫곤 한다.</p><p>방치된 상속물로 인해 코드가 복잡해지거나 문제가 생길때는 기존의 해결 방법을 따르기를 권하지만 대부분 심각하지 않기 때문에 리팩토링이 별로 필요하지 않다.</p><p>방치된 상속물의 구린내는 하위클래스가 기능은 재사용하지만 상위클래스의 인터페이스를 지원하진 않을 때 훨씬 심하게 풍긴다. 상속구현을 거부하는 것은 상관없지만, 인터페이스를 거부하는 것은 심각한 문제다. 하지만 그렇다고 계층구조를 건드려서는 안되고, <strong>상속을 위임으로 전환 기법</strong>을 적용해서 계층구조를 없애야 한다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="불필요한-주석">불필요한 주석<a aria-hidden="true" class="hash-link" href="#불필요한-주석" title="Direct link to heading">​</a></h2><p>주석이 다 필요 없다거나 주석을 작성하지 말라는 얘긴 아니다. 오히려 주석이 구린내를 감추기 위한 탈취제 역할로 쓰일 때가 문제이다.</p><p><strong>기능을 설명한 주석이 필요할 때는</strong></p><ul><li><strong>메서드 추출</strong>을 실시해야 한다.</li></ul><p><strong>추출된 상태임에도 설명한 주석이 여전히 필요하다면,</strong></p><ul><li><strong>메서드명 변경</strong>을 실시해야 한다.</li></ul><p><strong>시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는</strong></p><ul><li><strong>어썰션 넣기</strong>를 실시하면 된다.</li></ul><p><code>주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링 해서 주석을 없앨 수 있게 만들어보자.</code></p><p>주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다. <strong>돌아가는 원리</strong>, <strong>확실치 않은 부분</strong>, <strong>코드를 넣은 이유</strong>가 있을 때 주석을 넣는 것이 적절하다. 정보나 특히 잊기 쉬운 사항을 주석으로 작성해 놓으면 다른 사람들이 보고 쉽게 이해할 수 있다.</p></div></article><div class="comment-container"></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#중복-코드" class="table-of-contents__link toc-highlight">중복 코드</a></li><li><a href="#장황한-메서드" class="table-of-contents__link toc-highlight">장황한 메서드</a><ul><li><a href="#메서드-쪼개기" class="table-of-contents__link toc-highlight">메서드 쪼개기</a></li><li><a href="#조건문과-루프도-역시-메서드로-빼야한다" class="table-of-contents__link toc-highlight">조건문과 루프도 역시 메서드로 빼야한다.</a></li></ul></li><li><a href="#방대한-클래스" class="table-of-contents__link toc-highlight">방대한 클래스</a><ul><li><a href="#인스턴스가-많은-경우-중복-코드가-반드시-존재하기-마련이다" class="table-of-contents__link toc-highlight">인스턴스가 많은 경우 중복 코드가 반드시 존재하기 마련이다.</a></li><li><a href="#코드-분량이-너무-방대한-클래스에도-중복-코드가-많이-있기-마련이다" class="table-of-contents__link toc-highlight">코드 분량이 너무 방대한 클래스에도 중복 코드가 많이 있기 마련이다.</a></li><li><a href="#방대한-클래스가-gui인-경우" class="table-of-contents__link toc-highlight">방대한 클래스가 GUI인 경우</a></li></ul></li><li><a href="#과다한-매개변수" class="table-of-contents__link toc-highlight">과다한 매개변수</a></li><li><a href="#수정의-산발" class="table-of-contents__link toc-highlight">수정의 산발</a></li><li><a href="#기능의-산재" class="table-of-contents__link toc-highlight">기능의 산재</a></li><li><a href="#잘못된-소속" class="table-of-contents__link toc-highlight">잘못된 소속</a></li><li><a href="#데이터-뭉치" class="table-of-contents__link toc-highlight">데이터 뭉치</a></li><li><a href="#강박적-기본-타입-사용" class="table-of-contents__link toc-highlight">강박적 기본 타입 사용</a></li><li><a href="#switch문" class="table-of-contents__link toc-highlight">Switch문</a></li><li><a href="#평행-상속-계층" class="table-of-contents__link toc-highlight">평행 상속 계층</a></li><li><a href="#직무유기-클래스" class="table-of-contents__link toc-highlight">직무유기 클래스</a></li><li><a href="#막연한-범용-코드" class="table-of-contents__link toc-highlight">막연한 범용 코드</a></li><li><a href="#임시-필드" class="table-of-contents__link toc-highlight">임시 필드</a></li><li><a href="#메시지-체인" class="table-of-contents__link toc-highlight">메시지 체인</a></li><li><a href="#과잉-중개-메서드" class="table-of-contents__link toc-highlight">과잉 중개 메서드</a></li><li><a href="#지나친-관여" class="table-of-contents__link toc-highlight">지나친 관여</a></li><li><a href="#인터페이스가-다른-대용-클래스" class="table-of-contents__link toc-highlight">인터페이스가 다른 대용 클래스</a></li><li><a href="#미흡한-라이브러리-클래스" class="table-of-contents__link toc-highlight">미흡한 라이브러리 클래스</a></li><li><a href="#데이터-클래스" class="table-of-contents__link toc-highlight">데이터 클래스</a></li><li><a href="#방치된-상속물" class="table-of-contents__link toc-highlight">방치된 상속물</a></li><li><a href="#불필요한-주석" class="table-of-contents__link toc-highlight">불필요한 주석</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 COV. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.71916ec2.js"></script>
<script src="/assets/js/main.6ae0c4c9.js"></script>
</body>
</html>