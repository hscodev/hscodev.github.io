<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.8">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PNXVT1VNZJ"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-PNXVT1VNZJ",{anonymize_ip:!0})</script><title data-react-helmet="true">2장 리팩토링 개론 | COV</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hscodev.github.io/docs/etc/refactoring/02"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="2장 리팩토링 개론 | COV"><meta data-react-helmet="true" name="description" content="리팩토링은 무엇인가."><meta data-react-helmet="true" property="og:description" content="리팩토링은 무엇인가."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hscodev.github.io/docs/etc/refactoring/02"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/02" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/02" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.b67fb6af.css">
<link rel="preload" href="/assets/js/runtime~main.8ebe9818.js" as="script">
<link rel="preload" href="/assets/js/main.a4202966.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">COV</b></a><a class="navbar__item navbar__link" href="/docs/">Kotlin</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/etc/start_blog">ETC</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">객체지향의 사실과 오해</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/etc/start_blog">개발자 개인 블로그를 제작해보자.</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">리팩토링</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/01">1장 맛보기 예제</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/etc/refactoring/02">2장 리팩토링 개론</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/03">3장 코드의 구린내</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/04">4장 테스트 작성</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>2장 리팩토링 개론</h1></header><h2 class="anchor anchorWithStickyNavbar_31ik" id="리팩토링은-무엇인가">리팩토링은 무엇인가.<a aria-hidden="true" class="hash-link" href="#리팩토링은-무엇인가" title="Direct link to heading">​</a></h2><p><code>겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업</code></p><p><strong>리팩토링의 목적은 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것이다.</strong></p><ul><li>리팩토링은 성능최적화와 상반된다.<ul><li>성능 최적화를 수행할 때도 대게는 기능이 변경되지는 않지만 코드를 파악하기가 더 어려워질때가 많다. 필요한 성능을 얻으려면 어쩔 수 없이 해야한다.</li></ul></li></ul><p><strong>리팩토링은 겉으로 드러나는 소프트웨어 기능에 영향을 주지 않는다.</strong></p><ul><li>따라서 최종 사용자나 다른 프로그래머는 그 소프트웨어에 변화가 있음을 눈치채지 못한다.</li></ul><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="모자-두개">모자 두개<a aria-hidden="true" class="hash-link" href="#모자-두개" title="Direct link to heading">​</a></h3><p>위 두개의 내용은 켄트 벡의 <code>모자 두개 비유법</code>을 연상하게 한다. 리팩토링을 적용할 때 <code>기능 추가</code>와 <code>리팩토링</code>이라는 두 작업에 시간을 분배해야 한다.</p><p><strong>기능을 추가할 땐 코드를 수정하지 않고 기능만 추가해야 한다.</strong></p><ul><li>진행 상태를 파악하려면 테스트를 추가하고 그 테스트들이 제대로 되는지 알아내면 된다.</li></ul><p><strong>리팩토링할 때는 코드를 추가하지 말고 코드 구조 개선만 해야한다.</strong></p><ul><li>인터페이스가 변경되어 코드를 고치는 것이 불가피할 땐 테스트만 변경해야 한다.</li></ul><p>개발을 하다보면 기능 추가 편의를 위해 리팩토링을 겸하는 것 처럼 기능 추가 모자와 리팩토링 모자를 자주 바꿔 쓰게 된다. 작업 중에는 각 작업이 완료될 때까지는 반드시 본인이 현재 하고 있는 작업의 일관성을 유지해야 한다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="1-리팩토링은-왜-해야-할까">1. 리팩토링은 왜 해야 할까<a aria-hidden="true" class="hash-link" href="#1-리팩토링은-왜-해야-할까" title="Direct link to heading">​</a></h2><p>리팩토링의 가치는 확실하며 도구로서 다양한 용도로 사용 가능하다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="소프트-웨어-설계가-개선된다">소프트 웨어 설계가 개선된다.<a aria-hidden="true" class="hash-link" href="#소프트-웨어-설계가-개선된다" title="Direct link to heading">​</a></h3><p>프로그램 설계는 점점 노후된다. 불가피하게 단기적 목적과 설계를 완벽히 이해하지 않고도 수정이 발생한다. 그러니 코드의 <strong>처음 설계 구조를 유지하려면 정기적으로 리팩토링을 실시해야 한다.</strong></p><p>설계 개선의 주요 기법 중 하나는 중복코드 제거이다. 중복 코드의 제거는 코드를 수정할 때 비용이 절감된다. 중복 코드 제거는 깔끔한 설계의 필수 요건이다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="소프트웨어를-이해하기-더-쉬워진다">소프트웨어를 이해하기 더 쉬워진다.<a aria-hidden="true" class="hash-link" href="#소프트웨어를-이해하기-더-쉬워진다" title="Direct link to heading">​</a></h3><p>프로그래밍은 컴퓨터와 나누는 대화이다. 개발자는 다른 사람이 코드를 수정할 경우까지 고려하지 못할 수 있지만, 이러한 것을 고려하는 것도 중요하다. 이러한 점들에서 볼 때 프로그래밍에서 중요한 점은 <strong>의도한 바를 정확히 전달하는 것이다.</strong> 혹은 그 당사자가 미래의 자신일 수 있다.</p><p><strong>낯선 코드를 직접 리팩토링 하게 되면 쉽게 이해할 수 있다.</strong> 이러한 최초 단계의 리팩토링은 <code>우선 창 밖이 보이게 뿌연 유리창부터 닦는 일</code>과 같다고 했다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="버그를-찾기-쉬워진다">버그를 찾기 쉬워진다.<a aria-hidden="true" class="hash-link" href="#버그를-찾기-쉬워진다" title="Direct link to heading">​</a></h3><p>코드를 파악하기 쉬우면 버그 발견도 쉬워진다. 프로그램 구조를 명료하게 만들면 전제들이 확실해지고 버그를 놓치는 것이 불가능할 정도가 된다. 리팩토링을 통해 빈틈없는 코드를 효과적으로 작성할 수 있다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="프로그래밍-속도가-빨라진다">프로그래밍 속도가 빨라진다.<a aria-hidden="true" class="hash-link" href="#프로그래밍-속도가-빨라진다" title="Direct link to heading">​</a></h3><p>코드의 품질이 좋아진다는 사실은 쉽게 이해할 수 있다. 더불어 이러한 작업들은 오히려 개발 속도가 늦어지는 것이 아닌가 의문을 가질 수 있다.</p><p>깔끔한 설계야 말로 개발 속도를 높이기 위한 핵심이라고 확신한다. 설계의 목적 자체가 신속한 개발을 목적으로 한다. 설계가 깔끔하지 않다면 초기에는 빠를지라도 얼마 안가 느려지게 된다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="2-리팩토링은-어떨-때-필요할까">2. 리팩토링은 어떨 때 필요할까<a aria-hidden="true" class="hash-link" href="#2-리팩토링은-어떨-때-필요할까" title="Direct link to heading">​</a></h2><p>한달에 한번? 두달에 한번? 리팩토링은 일부러 시간내서 하지 말라고 답한다. 일상적으로 틈틈히 하자.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="같은-작업의-삼진-아웃-때">같은 작업의 삼진 아웃 때<a aria-hidden="true" class="hash-link" href="#같은-작업의-삼진-아웃-때" title="Direct link to heading">​</a></h3><p>한 작업을 할 때 처음은 그냥 하고 두번째 작업때는 중복 작업이라도 그냥 하고 세번째 하게 되면 리팩토링을 실시하자.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="기능을-추가할-때">기능을 추가할 때<a aria-hidden="true" class="hash-link" href="#기능을-추가할-때" title="Direct link to heading">​</a></h3><p>절실히 필요한 첫 번째 상황은 새 기능을 추가할 때이다.</p><p>두 번째 상황은 설계가 지저분해서 어떤 기능을 추가하기 힘들 때 이다.</p><p>리팩토링 과정은 신속하고 간단히 이루어지고 훨씬 쉽고 빠르게 기능을 추가할 수 있다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="버그를-수정할-때">버그를 수정할 때<a aria-hidden="true" class="hash-link" href="#버그를-수정할-때" title="Direct link to heading">​</a></h3><p>버그 리포트가 입수되었을 때도 리팩토링 해야한다. 버그가 있는 줄 몰랐을 만큼 코드가 지저분하다는 반증이기 때문이다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="코드를-검수할-때">코드를 검수할 때<a aria-hidden="true" class="hash-link" href="#코드를-검수할-때" title="Direct link to heading">​</a></h3><p>정기적으로 코드를 검수하자. 코드 검수를 통해 개발 팀원 모두가 코드를 파악하게 되며, 선임 개발자가 신입 개발자에게 지식을 전수하는 결과도 얻게 된다.</p><p>대규모 설계를 검수할 때는 코드보다는 UML 다이어그램과 CRC 카드를 이용한 시나리오 전개를 발표하는 방식이 좋다.</p><p>적극적인 코드 검수에 대한 설명은 익스트림 프로그래밍의 페어 프로그래밍을 참조하자. 개발과정 내내 지속적인 코드 검수와 리팩토링이 동시에 진행된다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="3-팀장에게-어떻게-말을-꺼내야-할까">3. 팀장에게 어떻게 말을 꺼내야 할까<a aria-hidden="true" class="hash-link" href="#3-팀장에게-어떻게-말을-꺼내야-할까" title="Direct link to heading">​</a></h2><p>대부분의 프로그래머는 품질에 대한 압박보다 일정에 대한 압박도 만만치 않다. 일정이 빠듯할 땐 리팩토링 얘길 꺼내지 말고 몰래 실시하자.</p><p>개발자의 임무는 전문가로서 효과적인 소프트웨어를 최대한 신속히 제작하기만 하면 된다. 역할과 책임을 가지고 리팩토링이 최단의 지름길인 것을 판단하여 리팩토링을 진행하자.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="-인다이렉션과-리팩토링">⭐ 인다이렉션과 리팩토링<a aria-hidden="true" class="hash-link" href="#-인다이렉션과-리팩토링" title="Direct link to heading">​</a></h2><p>개발자들은 인다이렉션을 광적으로 좋아한다는 점에서 리팩토링에 인다이렉션이 들어가는 경향도 당연하다. <strong>리팩토링은 방대한 객체와 장황한 메서드를 잘게 쪼개는 경향이 있다.</strong></p><p>인다이렉션은 양날의 검이다. 한 부분을 쪼개면 관리해야할 부분이 늘어난다. 작업을 다른 객체에 위임하기 때문에 코드를 알아보기 힘들어질 수도 있다. <strong>가능하다면 인다이렉션을 사용하는 것은 가능하면 자제하는 것이 좋다.</strong></p><p>인다이렉션도 다음과 같은 나름의 장점은 있기 때문에 잘 판단하자.</p><ul><li><strong>로직을 공유</strong><ul><li>여러 위치에서 호출되는 공유하는 상위 클래스의 메서드. 하나의 로직을 여러 곳에서 공유할 수 있다.</li></ul></li><li><strong>의도와 구현부를 따로 나타냄</strong><ul><li>클래스명과 메서드명을 정해서 의도한 바를 드러낼 수 있고 내부 코드로 어떻게 구현했는지 알 수 있다.</li></ul></li><li><strong>수정 부분을 분리</strong><ul><li>한 객체를 두 위치에 사용할 때 수정이 발생하면 두 위치 모두 영향 받을 수 있다. 이럴 때는 하위 클래스를 만들고 변하는 경우에 참조하게 할 수 있다.</li></ul></li><li><strong>조건문을 코드화</strong><ul><li>객체에는 재정의 메시지라는 우수한 메커니즘이 존재해서 조건문을 유연하면서도 분명하게 표현할 수 있다. 조건문을 메시지로 바꾸면 중복 코드가 줄어들어 명료해지며 동시에 유연성도 높아진다.</li></ul></li></ul><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="4-리팩토링-관련-문제들">4. 리팩토링 관련 문제들<a aria-hidden="true" class="hash-link" href="#4-리팩토링-관련-문제들" title="Direct link to heading">​</a></h2><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="데이터베이스">데이터베이스<a aria-hidden="true" class="hash-link" href="#데이터베이스" title="Direct link to heading">​</a></h3><p>애플리케이션은 데이터베이스 스키마와 강력히 결합되어있다. 이 때문에 데이터베이스 수정이 어려워진다. 꼼꼼히 계층구조로 제작하더라도 스키마를 수정하면 데이터도 이전해야 하는데, 이것은 시간도 오래걸리며 위험성도 높다.</p><p>해결 방법은 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법이 있다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="인터페이스-변경">인터페이스 변경<a aria-hidden="true" class="hash-link" href="#인터페이스-변경" title="Direct link to heading">​</a></h3><p>객체의 중대한 장점 중 하나는 인터페이스를 건드리지 않고 내부의 구현 코드를 수정할 수 있다는 점이다. 리팩토링에서 불안한 점은 인터페이스를 수정한다는 것이다. 이것이 객체의 주요 개념인 캡슐화에 어떤 영향을 미칠까?</p><p>내부적인 인터페이스는 대체적으로 문제되지 않는다. 하지만 인터페이스를 사용되는 부분을 찾는게 불가능하거나 수정할 수 없을 경우 문제가 생긴다.</p><p>이럴 때는 인터페이스 변경에 맞추어 수정되기 전까지는 기존 인터페이스와 새 인터페이스를 모두 유지해야한다. 기존 메서드가 새 메서드를 호출하게 해서 유지할 수 있게 한다.</p><p>인터페이스의 유지는 불편하고 까다로유며 비용도 계속 발생한다.</p><p>전체적으로는 결국 페어 프로그래밍을 이용하여 published 타입을 만들지 않는 것이 좋다. 또한 팀원간의 트러블이 생기지 않는 리팩토링을 위해 코드 소유권 정책을 수정하자.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="리팩토링을-어렵게-하는-설계를-수정하는-일">리팩토링을 어렵게 하는 설계를 수정하는 일<a aria-hidden="true" class="hash-link" href="#리팩토링을-어렵게-하는-설계를-수정하는-일" title="Direct link to heading">​</a></h3><p>설계에 오류가 있거나 설계에 대한 결정이 바뀌엇을 때 혹은 수정하기 민감판 부분도 리팩토링 할 수 있을까? - 거의 모든 경우는 리팩토링으로 해결된다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="리팩토링을-하면-안되는-상황">리팩토링을 하면 안되는 상황<a aria-hidden="true" class="hash-link" href="#리팩토링을-하면-안되는-상황" title="Direct link to heading">​</a></h3><p>대표적으로 <strong>코드를 새로 작성해야 할 때</strong>이다. 기존 코드가 지저분해서 완전히 새로 작성하는게 쉬울 떄가 있다. 코드가 돌아가지 않는다면 새로 작성하라는 신호이다.</p><p>한가지 절충안은 하나의 거대 소프트웨어를 강력한 캡슐화를 통해 여러개의 컴포넌트로 나누는 것이다. 그 다음 한번에 한개의 컴포넌트씩 리팩토링을 할 지 새로 작성할지 결정하면 된다.</p><p><strong>납기가 임박했을 때도 리팩토링은 삼가야 한다.</strong> 납기가 임박한 경우가 아니라면 시간을 핑계로 리팩토링을 미루면 안된다. 언제나 시간에 쫓긴다면 그건 리팩토링해야 한다는 신호이다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="5-리팩토링과-설계">5. 리팩토링과 설계<a aria-hidden="true" class="hash-link" href="#5-리팩토링과-설계" title="Direct link to heading">​</a></h2><p>리팩토링은 설계를 보완하는 특수한 역할을 한다.</p><p>기존에는 사전 설계 중 유연한 솔루션을 항상 찾게된다. 유연함이란 일반 솔루션보다 복잡해지고 유지보수 하기 힘들다. 유연함은 방법도 알아야하며, 유연함이 어디에 필요한지도 알아야 하지만 예측하는 것은 거의 불가능에 가깝다.</p><p>이 때 리팩토링을 실시하면 사전 설계는 적당한 솔루션을 이용할 수 있으며, 시스템을 구축하면서 제한사항 등을 더 자세히 파악 할 수 있게된다. 그리하여 유연성을 낮추지 않고도 더 간결한 설계가 가능해진다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="-빈-날짜-인스턴스를-생성하느라-낭비한-시간">⭐ 빈 날짜 인스턴스를 생성하느라 낭비한 시간<a aria-hidden="true" class="hash-link" href="#-빈-날짜-인스턴스를-생성하느라-낭비한-시간" title="Direct link to heading">​</a></h2><p>시스템이 느려진 이유를 개선하려고 아이디어를 모았다. 후에 프로파일러를 이용해 성능을 측정해보니 문제가 되는 지점을 찾게되었다.</p><p><strong>이 경험은 시스템 내부가 어떻게 돌아가는지 정확히 알고 있더라도 추측하지 말고 성능 측정을 실시해야 한다는 교훈을 준다</strong>.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="6-리팩토링과-성능">6. 리팩토링과 성능<a aria-hidden="true" class="hash-link" href="#6-리팩토링과-성능" title="Direct link to heading">​</a></h2><p>성능에 어떤 영향을 주는지에 가장 관심이 많은 것 같다.</p><p>리팩토링은 분명히 느려지긴 하지만 성능을 조절할 수 있다. 소프트웨어를 튜닝 가능하게 만들어놓고 충분한 속도가 나오게 튜닝할 수 있다.</p><p>성능이 좋은 소프트웨어를 작성할 수 있는 일반적인 세가지 방법은 다음과 같다.</p><p><strong>1. 시간 분배</strong></p><p>   설계를 분해하면서 각 구성 요소에 시간이나 메모리 사용량같은 예산을 할당한다. 일정 시간이 지나면 데이터가 쓸모 없어지는 심박 조정기 같은 시스템에서 서능 시간이 아주 중요하다.</p><p><strong>2. 성능에 꾸준한 관심을 갖는다.</strong></p><p>   이 방법은 성능을 높게 유지하기 위해 수단과 방법을 가리지 않는다. 이 경우 성능을 높이기 위해 수정한 것 때문에 작업하기 어려워지고 개발 속도도 떨어질 수 있따.</p><p><strong>3. 위 두 가지 장점을 활용한다.</strong></p><p>   성능 최적화 전까지 프로그램을 쪼개진 방식으로 제작하고, 성능 최적화 단계에서 튜닝하는 절차를 따른다.</p><p><strong>프로그램을 잘 쪼개면</strong> 두가지 측면에서 최적화 방식에 도움이 된다.</p><p><strong>1. 성능 튜닝에 할애할 시간이 생긴다.</strong>
<strong>2. 서능 분석할 때 더 정밀한 문석이 가능해진다.</strong></p><p>결국 단기적으로는 스프트웨어가 성능적으로 느리지만 튜닝하기가 쉬워지고 개발이 빨라진다.</p></div></article><div class="comment-container"></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/etc/refactoring/01"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->1장 맛보기 예제</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/etc/refactoring/03"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">3장 코드의 구린내<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#리팩토링은-무엇인가" class="table-of-contents__link toc-highlight">리팩토링은 무엇인가.</a><ul><li><a href="#모자-두개" class="table-of-contents__link toc-highlight">모자 두개</a></li></ul></li><li><a href="#1-리팩토링은-왜-해야-할까" class="table-of-contents__link toc-highlight">1. 리팩토링은 왜 해야 할까</a><ul><li><a href="#소프트-웨어-설계가-개선된다" class="table-of-contents__link toc-highlight">소프트 웨어 설계가 개선된다.</a></li><li><a href="#소프트웨어를-이해하기-더-쉬워진다" class="table-of-contents__link toc-highlight">소프트웨어를 이해하기 더 쉬워진다.</a></li><li><a href="#버그를-찾기-쉬워진다" class="table-of-contents__link toc-highlight">버그를 찾기 쉬워진다.</a></li><li><a href="#프로그래밍-속도가-빨라진다" class="table-of-contents__link toc-highlight">프로그래밍 속도가 빨라진다.</a></li></ul></li><li><a href="#2-리팩토링은-어떨-때-필요할까" class="table-of-contents__link toc-highlight">2. 리팩토링은 어떨 때 필요할까</a><ul><li><a href="#같은-작업의-삼진-아웃-때" class="table-of-contents__link toc-highlight">같은 작업의 삼진 아웃 때</a></li><li><a href="#기능을-추가할-때" class="table-of-contents__link toc-highlight">기능을 추가할 때</a></li><li><a href="#버그를-수정할-때" class="table-of-contents__link toc-highlight">버그를 수정할 때</a></li><li><a href="#코드를-검수할-때" class="table-of-contents__link toc-highlight">코드를 검수할 때</a></li></ul></li><li><a href="#3-팀장에게-어떻게-말을-꺼내야-할까" class="table-of-contents__link toc-highlight">3. 팀장에게 어떻게 말을 꺼내야 할까</a></li><li><a href="#-인다이렉션과-리팩토링" class="table-of-contents__link toc-highlight">⭐ 인다이렉션과 리팩토링</a></li><li><a href="#4-리팩토링-관련-문제들" class="table-of-contents__link toc-highlight">4. 리팩토링 관련 문제들</a><ul><li><a href="#데이터베이스" class="table-of-contents__link toc-highlight">데이터베이스</a></li><li><a href="#인터페이스-변경" class="table-of-contents__link toc-highlight">인터페이스 변경</a></li><li><a href="#리팩토링을-어렵게-하는-설계를-수정하는-일" class="table-of-contents__link toc-highlight">리팩토링을 어렵게 하는 설계를 수정하는 일</a></li><li><a href="#리팩토링을-하면-안되는-상황" class="table-of-contents__link toc-highlight">리팩토링을 하면 안되는 상황</a></li></ul></li><li><a href="#5-리팩토링과-설계" class="table-of-contents__link toc-highlight">5. 리팩토링과 설계</a></li><li><a href="#-빈-날짜-인스턴스를-생성하느라-낭비한-시간" class="table-of-contents__link toc-highlight">⭐ 빈 날짜 인스턴스를 생성하느라 낭비한 시간</a></li><li><a href="#6-리팩토링과-성능" class="table-of-contents__link toc-highlight">6. 리팩토링과 성능</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 COV. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8ebe9818.js"></script>
<script src="/assets/js/main.a4202966.js"></script>
</body>
</html>