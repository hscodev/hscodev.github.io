<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<title data-react-helmet="true">4장 테스트 작성 | COV</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hscodev.github.io/docs/etc/refactoring/04"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4장 테스트 작성 | COV"><meta data-react-helmet="true" name="description" content="리팩토링을 실시하기 위한 필수 전제조건은 반드시 견고한 테스트를 해야한다는 것이다. 테스트의 필요성은 리팩토링의 단점이 아니며, 리팩토링하지 않더라도 프로그래밍 속도가 월등히 빨라진다."><meta data-react-helmet="true" property="og:description" content="리팩토링을 실시하기 위한 필수 전제조건은 반드시 견고한 테스트를 해야한다는 것이다. 테스트의 필요성은 리팩토링의 단점이 아니며, 리팩토링하지 않더라도 프로그래밍 속도가 월등히 빨라진다."><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hscodev.github.io/docs/etc/refactoring/04"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/04" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hscodev.github.io/docs/etc/refactoring/04" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4d477d3e.css">
<link rel="preload" href="/assets/js/runtime~main.e34ff4a1.js" as="script">
<link rel="preload" href="/assets/js/main.843b30fc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">COV</b></a><a class="navbar__item navbar__link" href="/docs/">Kotlin</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/etc/start_blog">ETC</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/etc/start_blog">개발자 개인 블로그를 제작해보자.</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/etc/essence_of_oop/01">객체지향의 사실과 오해</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/etc/refactoring/01">리팩토링</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/01">1장 맛보기 예제</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/02">2장 리팩토링 개론</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/03">3장 코드의 구린내</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/etc/refactoring/04">4장 테스트 작성</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/etc/refactoring/05">5장 리팩토링 기법 카탈로그에 대해</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_2fq0" tabindex="0" href="/docs/etc/refactoring/06/06-overview">6장 메서드 정리</a><button aria-label="Toggle the collapsible sidebar category &#x27;6장 메서드 정리&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_2rXS"><div class="docItemContainer_1EXp"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_Ftrd"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>4장 테스트 작성</h1></header><p>리팩토링을 실시하기 위한 필수 전제조건은 반드시 견고한 테스트를 해야한다는 것이다. 테스트의 필요성은 리팩토링의 단점이 아니며, 리팩토링하지 않더라도 프로그래밍 속도가 월등히 빨라진다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="자가-테스트-코드의-가치">자가 테스트 코드의 가치<a aria-hidden="true" class="hash-link" href="#자가-테스트-코드의-가치" title="Direct link to heading">​</a></h2><p>테스트 코드를 작성하지 않는 프로그래머들은 업무 중 코드 작성 시간이 극히 짧고 디버깅 하는 시간이 대부분이다. 이런 경우 테스트 스위트를 작성하면 시간이 훨씬 절약된다.</p><p><code>모든 테스트를 완전히 자동화하고 결과를 자체적으로 검사하게 하자.</code></p><p><code>테스트 스위트는 버그를 찾는 시간을 획기적으로 줄여주는 강력한 버그 감지 도구다.</code></p><p>리팩토링엔 테스트가 필수이다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="junit-테스트-프레임워크">JUnit 테스트 프레임워크<a aria-hidden="true" class="hash-link" href="#junit-테스트-프레임워크" title="Direct link to heading">​</a></h2><p>Junit은 에릭 개머와 켄트 벡이 개발한 오픈소스 테스트 프레임워크다.</p><p>이 장에서 몇몇 입출력 클래스들의 테스트를 작성한다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="테스트-클래스-작성">테스트 클래스 작성<a aria-hidden="true" class="hash-link" href="#테스트-클래스-작성" title="Direct link to heading">​</a></h3><p>FilreReader 클래스를 테스트하는 FileReaderTester 클래스를 작성한다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class FileReaderTester extends TestCase{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public FileReaderTester (String name){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="테스트-픽스처-구성">테스트 픽스처 구성<a aria-hidden="true" class="hash-link" href="#테스트-픽스처-구성" title="Direct link to heading">​</a></h3><p>우선 테스트 픽스처를 구성해야 한다. 텍스트 픽스처란 테스트의 샘플 역할을 하는 객체를 일컫는다. 파일을 읽는 코드이므로 테스트에 쓸 data.txt 파일을 만든다.</p><p>TestCase 클래스에서는 픽스처를 조작할 수 있는 두 개의 메서드를 준비한다. <code>setUp</code> 메서드는 픽스처 객체를 생성하고, <code>tearDown</code>메서드는 픽스처 객체를 제거한다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected void setUp(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _input = new FileReader(&quot;data.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException exception){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(&quot;텍스트 파일을 열 수 없음&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected void tearDown(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _input.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException exception){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(&quot;파일을 닫는 중 오류 발생&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="테스트-작성">테스트 작성<a aria-hidden="true" class="hash-link" href="#테스트-작성" title="Direct link to heading">​</a></h3><p>두세개의 정도의 문자를 읽은 후 읽은 문자가 맞는 지 검사하자</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testRead() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char ch = &#x27;&amp;&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i=0; i &lt; 4; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch = (char) _input.read();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert(&#x27;d&#x27; == ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>자동 테스트는 assert가 담당한다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="테스트-스위트-작성">테스트 스위트 작성<a aria-hidden="true" class="hash-link" href="#테스트-스위트-작성" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static Test suite(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TestSuite suite = new TestSuite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    suite.addTest(new FileReaderTester(&quot;testRead&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return suite;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>메서드명을 인자로 넘긴다. 리플렉션을 통해 객체에 연결된다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="테스트-실행">테스트 실행<a aria-hidden="true" class="hash-link" href="#테스트-실행" title="Direct link to heading">​</a></h3><p><code>TestRunner</code> 클래스를 사용한다. TestRunner 클래스는 두가지가 있는데 하나는 결과를 GUI로 보여주고 하나는 글자로 보여준다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main (String[] args){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    junit.textui.TestRunner.run (suite());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>위 코드의 실행 결과는 다음과 같다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Time: 0.110</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    OK (1 test)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>JUnit은 실행되는 각 테스트마다 걸린 시간을 출력하므로 테스트 과정을 볼 수 있다.</p><p><code>테스트를 자주 실행하자. 적어도 하루에 한 번은 테스트를 실시하고, 컴파일할 때마다 테스트를 국소화하자.</code></p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="assert">Assert<a aria-hidden="true" class="hash-link" href="#assert" title="Direct link to heading">​</a></h3><p>주로 쓰이는 <code>assert</code> 메서드 형식은 두 값을 비교하여 같은지 검사하는 방식이다. 그래서 <code>assertEquals</code> 메서드가 있다. <code>assertEquals</code>를 사용하는 경우 오류가 발생했을 때 더욱 의미있는 문구로 확인할 수 있다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testRead() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char ch = &#x27;&amp;&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i=0; i &lt; 4; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch = (char) _input.read();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&#x27;d&#x27;, ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1) FileReaderTester.testRead &quot;expected:&quot;m&quot; but was: &quot;d&quot;&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="고의적인-버그">고의적인 버그<a aria-hidden="true" class="hash-link" href="#고의적인-버그" title="Direct link to heading">​</a></h3><p>테스트를 작성할 때 처음에 고의적인 버그를 넣는다. 실제로 수행되는지 스스로 입증하고 실제로 테스트도 하기 위함이다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="에러">에러<a aria-hidden="true" class="hash-link" href="#에러" title="Direct link to heading">​</a></h3><p>JUnit 프레임워크는 실패만 잡아내는 것이 아니고 에러도 잡아낸다. 실패는 어썰션 결과가 실패로 출력되고, 에러는 예끼치 못한 예외가 출력된다.</p><p>실패와 에러는 발생 원인도 다르고 디버깅 절차도 다르므로 구별하는 것이 좋다.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="단위-테스트와-기능-테스트">단위 테스트와 기능 테스트<a aria-hidden="true" class="hash-link" href="#단위-테스트와-기능-테스트" title="Direct link to heading">​</a></h2><p>이 프레임워크는 단위 테스트용이다. 그래서 단위 테스트와 기능 테스트의 차이를 짚고 넘어가자.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="단위-테스트">단위 테스트<a aria-hidden="true" class="hash-link" href="#단위-테스트" title="Direct link to heading">​</a></h3><p><strong>단위 테스트</strong>의 목적은 프로그래밍 생산성 향상이다. 생산성이 높아지면 부수적으로 품질 보증 부서의 업무 효율도 향상된다. 단위 테스트는 국소적이며, 각 테스트 클래스는 하나의 패키지 안에서만 효력이 있다.</p><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="기능-테스트">기능 테스트<a aria-hidden="true" class="hash-link" href="#기능-테스트" title="Direct link to heading">​</a></h3><p><strong>기능 테스트</strong>의 목적은 소프트웨어 전반이 제대로 돌아가는지 확인하는 것이다. 기능 테스트는 고객에게 품질 보증만 할 뿐 프로그래머의 생산성과는 무관하다. 따라서 기능 테스트 코드는 별도의 버그 발견 전문 팀이 개발해야 한다. 버그 발견 전문 팀은 기능 테스트 작성에 강력한 도구와 기술을 동원한다.</p><p>기능 테스트는 시스템을 블랙박스 취급하며 GUI 기반 시스템이라면, GUI를 통해 이뤄지고, 데이터 업데이트 프로그램에선 데이터가 특정 입력에 대해 어떻게 변하는지 관찰한다.</p><p>버그를 수정할 때는 두가지 조치를 해야한다.</p><ol><li>코드를 수정해서 버그를 없앤다.</li><li>그 버그를 출력하는 단위 테스트도 추가한다.</li></ol><p><code>버그 리포트를 받으면 우선 그 버그를 한눈에 볼 수 있게 출력하는 단위 테스트부터 작성하자.</code></p><p>리팩토링할 때에는 프로그래머의 친구인 단위 테스트를 애용하자.</p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="테스트-추가">테스트 추가<a aria-hidden="true" class="hash-link" href="#테스트-추가" title="Direct link to heading">​</a></h2><p>클래스가 수행해야 할 모든 작업을 파악하고 그 클래스가 실패할 만한 모든 조건마다 각 작업을 테스트하자. 모든 public 메서드를 테스트하기와는 다르다. 테스트는 위험을 위주로 작성해야 한다. 테스트를 너무 많이 작성하기에 질릴 수 있어서 버그 가능성이 거의 없는 부분은 테스트 작성 대상에서 제외시켜야 한다.</p><p><code>완벽한 테스트를 작성하려다 아예 테스트를 포기하느니, 차라리 불완전한 테스트를 작성해 실행하는 편이 낫다.</code></p><p>위 테스트에는 어떤 기능을 더 넣어야 할까. 파일 끝에서 -1을 반환하고 있다. 다음과 같이 테스트를 작성하자.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testReadAtEnd() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ch = -1234;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i=0; i &lt; 141; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch = (char) _input.read();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;read at end&quot;, -1, _input.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>실행하려면 다음과 같이 테스트 스위트에 넣는다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static Test suite(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TestSuite suite = new TestSuite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    suite.addTest(new FileReaderTester(&quot;testRead&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **suite.addTest(new FileReaderTester(&quot;testReadAtEnd&quot;));**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return suite;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 방식은 스위트에 포함하는 것을 까먹을 수 있다. 다음 방식과 같이 test로 시작하는 모든 테스트를 테스트 스위트로 생성할 수 있다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main (String[] args){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    junit.textui.TestRunner.run (new TestSuite(FileReaderTester.class));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="경계-조건">경계 조건<a aria-hidden="true" class="hash-link" href="#경계-조건" title="Direct link to heading">​</a></h3><p>테스트에서 가장 힘든 일은 경계 조건을 찾는 것이다. 파일 읽기 메서드에서 경계는 다음과 같이 첫 글자, 마지막 글자, 마지막 글자 바로 뒤의 글자다.</p><p><code>잘못될 수 있는 경계 조건을 생각한 후, 그 상황에서의 테스트에 집중하자.</code></p><p>경계 찾기에는 테스트를 실패하게 할 가능성이 있는 특수 조건을 찾는 작업도 포함된다. 파일이 비어 있을 경우를 특수 조건으로 사용하는게 적절하다.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testEmptyRead() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    File empty = new file(&quot;empty.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileOutputStream out = new FileOutputStream(empty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    out.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileReader in = newFileReader(empty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(-1, in.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><br><h3 class="anchor anchorWithStickyNavbar_31ik" id="에러-조건">에러 조건<a aria-hidden="true" class="hash-link" href="#에러-조건" title="Direct link to heading">​</a></h3><p>개발자가 파일 끝보다 뒤를 읽으려 하면 어떻게 될까? 분명히 -1이 반환될 것이므로 이를 검사하는 다른 테스트를 하나 추가하자.</p><div class="codeBlockContainer_K1bP language-java"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testReadBoundaries() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;read first char&quot;, &#x27;B&#x27;, _input.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i=0; i &lt; 140; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch = (char) _input.read();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;read last char&quot;, &#x27;6&#x27;, _input.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;read at end&quot;, -1, _input.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;read past end&quot;, -1, _input.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>뭔가 에러가 있으리라 예상될 땐 그 예외가 정말로 발생하는지 꼭 테스트하자.</code></p><br><h2 class="anchor anchorWithStickyNavbar_31ik" id="마무리">마무리<a aria-hidden="true" class="hash-link" href="#마무리" title="Direct link to heading">​</a></h2><p>테스트에 살을 붙이는 작업이 그런 식으로 계속 된다. 인터페이스는 시간이 걸리지만 작업 과정에서 깊히 이해하게 된다. 에러 조건과 경계 조건에 관해 생각하는 일이 쉬워진다.</p><p><code>테스트가 모두는 아니더라도 대부분의 버그는 잡아내므로 테스트 작성을 중단해선 안된다.</code></p><p>객체의 한가지 단점은 상속과 재정의로 인해 테스트할 조합이 너무 많아져서 테스트가 어려워질 수 있다는 점이다.  모든 버그를 잡아내려고 며칠을 낭비하는 것 보다 적당한 시간을 들여서 대부분의 버그를 잡아내는 것이 낫다.</p></div></article><div class="comment-container"></div><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#자가-테스트-코드의-가치" class="table-of-contents__link toc-highlight">자가 테스트 코드의 가치</a></li><li><a href="#junit-테스트-프레임워크" class="table-of-contents__link toc-highlight">JUnit 테스트 프레임워크</a><ul><li><a href="#테스트-클래스-작성" class="table-of-contents__link toc-highlight">테스트 클래스 작성</a></li><li><a href="#테스트-픽스처-구성" class="table-of-contents__link toc-highlight">테스트 픽스처 구성</a></li><li><a href="#테스트-작성" class="table-of-contents__link toc-highlight">테스트 작성</a></li><li><a href="#테스트-스위트-작성" class="table-of-contents__link toc-highlight">테스트 스위트 작성</a></li><li><a href="#테스트-실행" class="table-of-contents__link toc-highlight">테스트 실행</a></li><li><a href="#assert" class="table-of-contents__link toc-highlight">Assert</a></li><li><a href="#고의적인-버그" class="table-of-contents__link toc-highlight">고의적인 버그</a></li><li><a href="#에러" class="table-of-contents__link toc-highlight">에러</a></li></ul></li><li><a href="#단위-테스트와-기능-테스트" class="table-of-contents__link toc-highlight">단위 테스트와 기능 테스트</a><ul><li><a href="#단위-테스트" class="table-of-contents__link toc-highlight">단위 테스트</a></li><li><a href="#기능-테스트" class="table-of-contents__link toc-highlight">기능 테스트</a></li></ul></li><li><a href="#테스트-추가" class="table-of-contents__link toc-highlight">테스트 추가</a><ul><li><a href="#경계-조건" class="table-of-contents__link toc-highlight">경계 조건</a></li><li><a href="#에러-조건" class="table-of-contents__link toc-highlight">에러 조건</a></li></ul></li><li><a href="#마무리" class="table-of-contents__link toc-highlight">마무리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/hscodev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 COV. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e34ff4a1.js"></script>
<script src="/assets/js/main.843b30fc.js"></script>
</body>
</html>